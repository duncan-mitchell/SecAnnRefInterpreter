// If %throwUnboundIDErrors is false, we attempt to emulate non-strict mode
// behavior by assigning to the top-level context when the LHS of the assignment is
// an undeclared identifier.
let [%throwUnboundIDErrors] = false

{(/*:START SYM EVAL*/0)}

let [%ObjectProto] = { [#proto : null,] }

let [%global] = { [#proto : %ObjectProto,] }
let [%globalContext] = {[#proto: %global, #extensible: true,]}

let [%Immut] = func(obj, prop) {
  prim("pretty", obj);
  obj[prop<#enumerable> = false];
  obj[prop<#configurable> = false]
}

rec [%protoOfField] = func(object, fld) {
  if (object === null) { object }
  else if (prim("hasOwnProperty", object, fld)) { object }
  else { %protoOfField(object[<#proto>], fld) }
}

let [%isUnbound] = func(context, id) {
  %protoOfField(context, id) === %globalContext &&
  prim("!", prim("hasProperty", %global, id))
}
{(/*:STOP SYM EVAL*/0)}

{(/*:START SYM EVAL*/0)}

let [%FunctionProto] = {
  [#proto: %ObjectProto, #class : "Function", #code : func(this, args){ undefined },]
  "length" : {#value 0, #writable true} }

{(/*:STOP SYM EVAL*/0)}

let [%functionToStringlambda] = func(this, args) {
  "function ToString"
}

let [%functionToString] = 
  { [#code : %functionToStringlambda, #proto: %FunctionProto, #class: "Function",] 
  "length" : {#value 0, #writable false, #configurable false, #enumerable false} }

{
  %FunctionProto["toString" = %functionToString];
  %FunctionProto["toString"<#enumerable> = false]
}

let [%ErrorProto] = {[#proto : %ObjectProto, #class : "Error",]}

let [%TypeErrorProto] = { [#proto : %ErrorProto,] }

let [%MakeTypeError] = func(msg) {
  let (msg = if (typeof msg === 'object') { 'object passed to ThrowTypeError' }
             else { prim("prim->str", msg) })
  {[#proto : %TypeErrorProto,]
    message: {#value msg, #writable false} }
}

let [%IsJSError] = func(thing) {
  typeof thing === "object" && prim("hasOwnProperty", thing, "%js-exn")
}

let [%ToJSError] = func(maybe-js-error) {
  if (%IsJSError(maybe-js-error)) {
    maybe-js-error["%js-exn"]
  }
  else if (maybe-js-error === "unwritable-field") {
    %MakeTypeError("Field not writable")
  }
  else if (maybe-js-error === "unconfigurable-delete") {
    %MakeTypeError("Field not deletable")
  }
  else { throw maybe-js-error }
}

let [%JSError] = func(err) {
  { [] "%js-exn" : {#value err, #writable false} }
}

let [%ThrowTypeErrorFun] = func(this, args) {
  let (msg = args["0"])
  throw %JSError(%MakeTypeError(msg))
}

let [%ThrowTypeError] = {[
    #code: %ThrowTypeErrorFun,
    #proto: %FunctionProto,
    #extensible: false,
    #class: "Function",
  ]
  "length": {#value 0, #writable false}
}

let [%TypeError] = func(msg) {
  %ThrowTypeErrorFun(undefined, {[] "0": {#value msg, #writable false}})
}


// Errors that may be JavaScript and may be from the interpreter are
// handled here
let [%ErrorDispatch] = func(maybe-js-error) {
  if (%IsJSError(maybe-js-error)) { throw maybe-js-error }
  else if (maybe-js-error === "unwritable-field") {
    %TypeError("Field not writable")
  }
  else if (maybe-js-error === "unconfigurable-delete") {
    %TypeError("Field not deletable")
  }
  else { throw maybe-js-error }
}

let [%ReferenceErrorProto] = { [#proto : %ErrorProto,] }

let [%SyntaxErrorProto] = { [#proto : %ErrorProto,] }

let [%SyntaxError] = func(msg) {
  throw %JSError({[#proto: %SyntaxErrorProto,]
                  message: {#value msg, #writable false}})
}

let [%BooleanProto] = 
  { [#proto : %ObjectProto, #class : "Boolean", #primval : false,]}


let [%NumberProto] = { [#proto : %ObjectProto, #class : "Number", #primval : 0,]}

let [%ToBoolean] = func(x) {
  prim("prim->bool", x)
}

let [%ObjectTypeCheck] = func(o) {
  let (t = prim("typeof", o))
  let (c1 = t !== "object")
  let (c2 = t !== "function")
  if (c1 && c2) {
    %TypeError(prim("string+", prim("prim->str", o), " is not an object"))
  } else { null }
}

let [%IsObject] = func(o) {
  let (t = prim("typeof", o))
  let (c1 = t === "object")
  let (c2 = t === "function")
  c1 || c2
}

let [%AppExprCheck] = func(fun, args) {
  if(typeof fun !== "function") {
    %TypeError("Not a function")
  } else {
    fun(undefined, args)
  } 
}

// NOTE(joe): not complete, because window could just define getters that throw
//  This should intelligently determine when a variable is free
let [%Typeof] = func(context, id) {
  try { prim("typeof", context[id]) } catch { func(e) { 'undefined' } }
}


let [%instanceof] = func(l, r) {
  let (rtype = prim("typeof", r))
  let (ltype = prim("typeof", l))
  label ret: {
    if (rtype !== "function") {
      %TypeError("Non-function given to instanceof")
    } else { null };

    if (ltype !== "function" && ltype !== "object") {
      break ret false
    } else { null };

    let (O = r["prototype"])
    let (Otype = prim("typeof", O)) {
      if (Otype !== "function" && Otype !== "object") {
        %TypeError("Prototype was not function or object")
      } else { null };

      rec (search = func(v) {
        let (vp = v[<#proto>])
        if (vp === null) {
          false
        } else {
          if (O === vp) {
            true
          } else {
            search(vp)
          }
        }
      })
      break ret search(l)
    }
  }
}


{(/*:START SYM EVAL*/0)}

let [%StringProto] = { [#proto : %ObjectProto, #class : "String", #primval : "",] 
  "length" : {#value 0, #writable false}}

{(/*:STOP SYM EVAL*/0)}

let [%StringIndices] = func(obj, s) {
  let (len = prim("strlen", s))
  rec (loop = func(i) {
    if (prim("<", i, len)) {
      obj[prim("prim->str", i) = prim("char-at", s, i)];
      loop(prim("+", i, 1))
    } else { undefined }
  })
  loop(0)
}

let [%ToObject] = func (o) {
    if (o === null) { 
	    %TypeError("%ToObject received null")
    } else {
        label ret : {
            let (t = prim("typeof", o)) {
		if (t === "object" || t === "function") {
		    break ret o
		}
		else { null };
		if (t === "string") {
		    let (obj = 
			 {[#class: "String", 
                           #extensible: true,
                           #proto: %StringProto,
                           #primval: o,]
		 	   "length" : {#value prim("strlen", o), #writable true}}) {
			    %StringIndices(obj, o);
			break ret obj
		    }
		}
		else { null };
		if (t === "number") {
		    break ret
		    {[#class: "Number",
                      #extensible: true,
                      #proto: %NumberProto,
                      #primval: o,]}
		}
		else { null };
		if (t === "boolean") {
		    break ret
		    {[#class: "Boolean",
                      #extensible: true,
                      #proto: %BooleanProto,
                      #primval: o,]}
		}
		else { null };  
		if (t === "function") {
		    break ret
		    {[#class: "Function",
                      #extensible: true,
                      #proto: %BooleanProto,
                      #primval: o,]}
		}
		else { null };
		%TypeError("%ToObject received undefined")
	    }
	}
    }
}

// See 11.2.1, step 2
// Property accessor semantics require us to throw a ReferenceError when the 
// "object" part of the bracket expression is undefined.
let [%PropAccessorCheck] = func(o) {
  if (o === undefined) {
    throw %JSError({[#proto : %ReferenceErrorProto,]})
  } else {
    %ToObject(o)
  }
}


let [%UnboundId] = func(id) {
  throw %JSError(
    { [#proto : %ReferenceErrorProto,]
      "message": {#value prim("string+", "Unbound identifier: ", id), #writable true}
    }
  )
}

let [%ThrowReferenceError] = {
    [ #code : func(this, args) {
        throw %JSError({ [#proto : %ReferenceErrorProto,] })
      },]}

let [%SyntaxError] = func(msg) {
  throw %JSError({ [#proto : %SyntaxErrorProto,]
    "message": {#value prim("string+", "ReferenceError: ", msg),
                #writable true}})
}

let [%ThrowSyntaxError] = {
    [ #code : func(this, args) {
        throw %JSError({ [#proto : %SyntaxErrorProto,] })
      },
      #extensible: false,]}

let [%ToPrimitiveNum] = func(obj) {
  let (check = func(o, str) {
    let (valueOf = o[str])
    if (prim("typeof", valueOf) === "function") {
        let (str = valueOf(o, {[]}))
        if (prim("primitive?", str)) {
            str
        } else { null }
    } else { null }
  })
  let (r1 = check(obj, "valueOf"))
  if (r1 !== null) { r1 } else {
    let (r2 = check(obj, "toString"))
    if (r2 !== null) { r2 } else {
      %TypeError("valueOf and toString both absent in toPrimitiveNum")
    }
  }
}

let [%ToPrimitiveStr] = func(obj) {
    label ret : {
	let (toString = obj["toString"])
	if (prim("typeof", toString) === "function") {
            let (str = toString(obj, {[]})) {
		if (prim("primitive?", str)) {
                    break ret str
		}
		else { null }
            }
	};
	let (valueOf = obj["valueOf"])
	if (prim("typeof", valueOf) === "function") {
            let (str = valueOf(obj, {[]})) {
		if (prim("primitive?", str)) {
                    break ret str
		}
		else { null }
            }
	};
	%TypeError("valueOf and toString both absent in toPrimitiveStr")
    }
}

let [%ToPrimitiveHint] = func(val, hint) {
    let (t = prim("typeof", val))
    if(t === "function" || t === "object") {
        if(hint === "string") {
            %ToPrimitiveStr(val)
        }
        else {
            %ToPrimitiveNum(val)
        }
    }
    else {
        val
    }
}

let [%ToPrimitive] = func(val) {
    // TODO exception for date objects
    %ToPrimitiveHint(val, "number")
}


let [%ToString] = func(val) {
    prim("prim->str", %ToPrimitiveHint(val, "string"))
}

// NOTE(joe): in non-strict mode this will need to be changed This is not
// exactly 10.4.3 because getters and setters pass ToObject() forms of numbers.
// The real solution might be to have 4-place get/set methods
let [%resolveThis] = func(strict, obj) {
  if (strict) {
    if (typeof obj === 'object' && obj !== null) {
      let (klass = obj[<#class>])
      if ((klass === "Number" || klass === "String" || klass === "Boolean")
          && (obj !== %StringProto && obj !== %NumberProto && obj !== %BooleanProto)) {
        obj[<#primval>]
      } else {
        obj
      }
    } else {
      obj
    }
  } else {
    if ((obj === null) || (obj === undefined)) {
      %global
    } else {
      obj
    }
  }
}

let [%in] = func(l, r) {
  let (rtype = prim("typeof", r))
  if (rtype !== "object" && rtype !== "function") {
    %TypeError(prim("string+", %ToString(r), " is not an object"))
  } else {
    prim("hasProperty", r, %ToString(l))
  }
}

let [%ToNumber] = func(x) {
  label ret: {
    let (t = prim("typeof", x)) {
        if (t === "number") {
          break ret x
        };
        if (t === "string") {
          break ret prim("numstr->num", x)
        };
        %TypeError("ToNumber")
    }
  }
}

let [%AssertNumber] = func(x) {
    if (prim("typeof", x) === "number") {
        x
    } else {
        %TypeError("AssertNumber")
    }
}

let [%AssertString] = func(x) {
    if (prim("typeof", x) === "string") {
        x
    } else {
        %TypeError("AssertString")
    }
}

let [%ToInteger] = func(i) { 
    label ret: {
  let (number = %ToNumber(i)) {
      if (number !== number) {
    break ret 0
      } else { null };
      if (number === 0 || number === +inf || number === -inf) { 
    break ret number
      } else { null };
      // Why 0 - 1? No negative number literals (yet)
      let (sign = if (prim("<", number, 0)) { prim("-", 0, 1) } else { 1 })
      let (a = prim("abs", number))
      let (f = prim("floor", a))
      let (r = prim("*", sign, f))
      break ret r
  }
    }
}


let [%NumberConstructor] = func(this, args) {
  if (this === undefined) {
    if (args["length"] === 0) { 0 } else { %ToNumber(args["0"]) }
  } else {
    let (hasProp = prim("hasProperty", args, "0"))
    let (argUndef = args["0"] === undefined)
    let (v = if (hasProp && argUndef) { NaN }
             else if (argUndef) { 0 }
             else { %ToNumber(args["0"]) })
    { [#proto : %NumberProto, #class : "Number", #primval : v,] }
  }
}

let [%isNaNlambda] = func(this, args) {
    let (n = %ToNumber(args["0"]))
    n !== n
}

// 11.9.3
let [%EqEq] = rec (eqeq = func(x1, x2) {
    label ret : {
	let (t1 = prim("typeof", x1))
	let (t2 = prim("typeof", x2))
	if(t1 === t2) {
	    if(t1 === "undefined") {
		break ret true
	    }
	    else {
		if(t1 === "null") {
		    break ret true }
		else {
		    if(t1 === "number") {
			break ret (x1 === x2) }
		    else {
			if(t1 === "string") {
			    break ret (x1 === x2) }
			else {
			    if(t1 === "object") {
				break ret (x1 === x2) }
			    else {
                            if(t1 === "boolean") {
                                break ret (x1 === x2) }
                            else {
				throw "[env] Catastrophe---unknown type in ==" }
			}}}}}}
	else {
	    
            if((x1 === undefined && x2 === null) ||
               (x1 === null && x2 === undefined)) {
		break ret true }
            else {
		if(t1 === "number" && t2 === "string") {
                    break ret (x1 === prim("prim->num", x2)) }
		else {
                    if(t1 === "string" && t2 === "number") {
			break ret (prim("prim->num", x1) === x2) }
                    else {
			if(t1 === "boolean") {
                            break ret (eqeq(prim("prim->num", x1), x2)) }
			else {
                            if (t2 === "boolean") {
				break ret (eqeq(x1, prim("prim->num", x2))) }
                            else {
				if((t1 === "string" || t1 === "number") &&
				   (t2 === "object")) {
                                    break ret eqeq(x1, %ToPrimitive(x2)) }
				else {
                                    if((t2 === "string" || t2 === "number") &&
                                       (t1 === "object")) {
					break ret eqeq(%ToPrimitive(x1), x2) }
                                    else {
					break ret false }
				}}}}}}}}}) eqeq

let [%printlambda] = func(o, s) {
    prim("print", %ToString(s["0"]))
}

let [%print] = { [#code : %printlambda, #proto: %FunctionProto,] }

let [%len] = func(list) {
    rec (inner_len = func(iter) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                prim("+", 1, inner_len(prim("+", 1, iter)))
            }
            else { iter }
        })
    inner_len(0)
}

let [%slice_internal] = func(list, min, max) {
    let (retObj = {[#extensible: true,]}) {
	rec (inner_slice = func(iter, ix) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                retObj[prim("prim->str", ix) = list[prim("prim->str", iter)] ];
                if(prim(">", iter, max)) { undefined }
                else { inner_slice(prim("+", iter, 1), prim("+", ix, 1)) }
            }
            else { retObj["length" = ix] }
        })
	inner_slice(min, 0);
	retObj
    }
}

let [isDataField] = func(obj, field) {
    ((obj[field<#value>] !== undefined) ||
     (obj[field<#writable>] !== undefined))
}

let [isAccessorField] = func(obj, field) {
    ((obj[field<#setter>] !== undefined) ||
     (obj[field<#getter>] !== undefined))
}

let [isGenericField] = func(obj, field) {
    (isDataField(obj, field) === false &&
     isAccessorField(obj, field) === false)
}

let [isDataDescriptor] = func(attr-obj) {
    (typeof (attr-obj["value"]) !== "undefined" ||
     typeof (attr-obj["writable"]) !== "undefined")
}

let [isAccessorDescriptor] = func(attr-obj) {
    (typeof (attr-obj["set"]) !== "undefined" ||
     typeof (attr-obj["get"]) !== "undefined")
}

let [isGenericDescriptor] = func(attr-obj) {
    (isAccessorDescriptor(attr-obj) === false &&
     isDataDescriptor(attr-obj) === false)
}

let [copy-when-defined] = func(obj1, obj2, s) {
    if(obj2[s] !== undefined) {
	obj1[s = obj2[s] ]
    }
    else { undefined }
}

let [copy-data-desc] = func(obj1, obj2) {
    copy-when-defined(obj1, obj2, "configurable");
    copy-when-defined(obj1, obj2, "enumerable");
    copy-when-defined(obj1, obj2, "writable");
    copy-when-defined(obj1, obj2, "value");
    obj1[delete "get"];
    obj1[delete "set"]

}

let [copy-access-desc] = func(obj1, obj2) {
    copy-when-defined(obj1, obj2, "configurable");
    copy-when-defined(obj1, obj2, "enumerable");
    copy-when-defined(obj1, obj2, "set");
    copy-when-defined(obj1, obj2, "get");
    obj1[delete "value"];
    obj1[delete "writable"]
}

// 8.12.9
let [%defineOwnProperty] = func(obj, field, attr-obj) {
  let (t = typeof obj)
  if (t !== "object" && t !== "function") { throw "defineOwnProperty didn't get object" }
  else { undefined };
  let (fstr = %ToString(field))
  if (prim("hasOwnProperty", obj, fstr) === false) {
    if (obj[<#extensible>]) {
      // Do this to open it up for the other properties (will set these last)
      obj[fstr<#configurable> = true];
      obj[fstr<#writable> = true];

  		{if(isDataDescriptor(attr-obj)) {
          obj[fstr<#value> = attr-obj["value"] ];
          obj[fstr<#writable> = %ToBoolean(attr-obj["writable"]) ]
      }
      else if(isAccessorDescriptor(attr-obj)) {
          obj[fstr<#getter> = attr-obj["get"] ];
          obj[fstr<#setter> = attr-obj["set"] ]
  		}
  		else { undefined }};

      obj[fstr<#enumerable> = %ToBoolean(attr-obj["enumerable"]) ];
      obj[fstr<#configurable> = %ToBoolean(attr-obj["configurable"]) ];
      true
    }
    else { %TypeError("(defineOwnProperty) Attempt to add a property to a non-extensible object.") }
  }
	else { /* it definitely has the property */
    let(current-prop = {[#extensible: true,]
      configurable: {#value obj[fstr<#configurable>], #writable true},
      enumerable: {#value obj[fstr<#enumerable>], #writable true}
    }) {
    if (prim("isAccessor", obj, fstr)) {
      current-prop["get" = obj[fstr<#getter>]];
      current-prop["set" = obj[fstr<#setter>]]
    }
    else {
      current-prop["writable" = obj[fstr<#writable>]];
      current-prop["value" = obj[fstr<#value>]]
    };
	  if (obj[fstr<#configurable>] === false) {
      if (attr-obj["configurable"] === true) {
		    %TypeError("escalating configurable from false to true")
      }
      else {
        if(attr-obj["enumerable"] === (obj[fstr<#enumerable>] === false)) {
          %TypeError("(defineOwnPoperty) Can't change enumerable of a non-configurable property")
        }
      };
      if ((isDataDescriptor(current-prop)) !== (isDataDescriptor(attr-obj))) {
        if (obj[fstr<#configurable>] === false) {
          %TypeError("(defineOwnProperty) Non-configurable property")
        }
        else {
          if (isDataDescriptor(current-prop)) {
            copy-data-desc(current-prop, attr-obj)
          }
          else {
            copy-access-desc(current-prop, attr-obj)
          }
        }
      }
    };
		// current-prop is what?
		if ((isDataDescriptor(current-prop)) && 
			 (isDataDescriptor(attr-obj))) {
		    if (current-prop["configurable"] === false) {
			if (current-prop["writable"] === false) {
			    if (attr-obj["writable"] === true) {
				%TypeError("(defineOwnProperty) Cannot escalate writable from false to true.")
			    }
			    else {
				    if (prim("sameValue", attr-obj["value"], current-prop["value"]) === false) {
  				    %TypeError("(defineOwnProperty) Cannot change a non-configurable value")
				}
				else { copy-data-desc(current-prop, attr-obj) }
			    }
			}
			else { copy-data-desc(current-prop, attr-obj) }
		    }
		    else { copy-data-desc(current-prop, attr-obj) }
		}
		else {
		    if (current-prop["configurable"] === false) {
			    if (prim("sameValue", current-prop["set"], attr-obj["set"]) === false ||
			        prim("sameValue", current-prop["get"], attr-obj["get"]) === false) {
      %TypeError(prim("string+", "(defineOwnProperty) Cannot change setter or getter of non-configurable property ", fstr))
			}
			else { copy-access-desc(current-prop, attr-obj) }
		    }
		    else { copy-access-desc(current-prop, attr-obj) }
		};

		if(isDataDescriptor(current-prop)) {
      if (prim("sameValue", obj[fstr<#value>], current-prop["value"]) === false) {
		    obj[fstr<#value> = current-prop["value"]]
      };
      if(obj[fstr<#writable>] !== current-prop["writable"]) {
  		  obj[fstr<#writable> = current-prop["writable"]]
      }
		}
		else if(isAccessorDescriptor(current-prop)) {
		    obj[fstr<#getter> = current-prop["get"]];
		    obj[fstr<#setter> = current-prop["set"]]
		}
		else { undefined };
		
    if(obj[fstr<#enumerable>] !== current-prop["enumerable"]) {
  		obj[fstr<#enumerable> = current-prop["enumerable"]]
    };
    if(obj[fstr<#configurable>] !== current-prop["configurable"]) {
  		obj[fstr<#configurable> = current-prop["configurable"]]
		};
		true
    }
	}
}

// Defines a property on an object from section 15.
// If given attributes, uses them, otherwise, uses the defaults
// as specified at the end of the intro to 15:
//    In every case, the length property of a built-in Function object
//    described in this clause has the attributes { [[Writable]]: false,
//    [[Enumerable]]: false, [[Configurable]]: false }. Every other property
//    described in this clause has the attributes { [[Writable]]: true,
//    [[Enumerable]]: false, [[Configurable]]: true } unless otherwise
//    specified.
let [%define15Property] = func(obj, field, prop) {
  let (%mkPropObj = func(value, writable, enumerable, configurable) {
    if (value !== null) {
      {[] "value": {#value value, #writable true},
	        "writable" : {#value writable, #writable true},
          "enumerable" : {#value enumerable, #writable true},
          "configurable" : {#value configurable, #writable true}}
    } else {
      {[] "writable" : {#value writable, #writable true},
          "enumerable" : {#value enumerable, #writable true},
          "configurable" : {#value configurable, #writable true}}
    }
  })
  if ((typeof obj) === "function" && field === "length") {
    %defineOwnProperty(obj, field, %mkPropObj(prop, false, false, false))
  }
  else {
    %defineOwnProperty(obj, field, %mkPropObj(prop, true, false, true))
  }
}

let [%definePropertylambda] = func(this, args) {
    let (obj = args["0"])
    let (field = args["1"])
    let (propobj = args["2"])
    // 8.10.5 checks
    
    if (%ObjectTypeCheck(obj)) {
	%TypeError("defineProperty didn't get object")
    }
    else {
	let (attrobj = {[#extensible: true,]}) {
	    let (enumerable = propobj["enumerable"]) {
		if ((typeof enumerable) !== "undefined") {
		    attrobj["enumerable" = enumerable]
		}
		else { attrobj }
	    };
	    
	    let (configurable = propobj["configurable"]) {
		if ((typeof configurable) !== "undefined") {
		    attrobj["configurable" = configurable]
		}
		else { attrobj }
	    };
	
	    let (writable = propobj["writable"]) {
		if ((typeof writable) !== "undefined") {
		    attrobj["writable" = writable]
		}
		else { attrobj }
	    };
	    
	    let (value = propobj["value"]) {
		if ((typeof value) !== "undefined") {
		    attrobj["value" = value]
		}
		else { attrobj }
	    };
	
	    let (get = propobj["get"]) {
		if ((typeof get) !== "undefined" && 
		    (prim("typeof", get) !== "function")) {
		    %TypeError("defineProperty given a non-function getter")
		}
		else {
		    attrobj["get" = get]
		}
	    };
	
	    let (set = propobj["set"]) {
		if (typeof set !== "undefined" && 
		    (prim("typeof", set) !== "function")) {
		    %TypeError("defineProperty given a non-function setter")
		}
		else {
		    attrobj["set" = set]
		}
	    };

	    // 8.10.5, step 9
	    if ((isDataDescriptor(attrobj)) && 
		(isAccessorDescriptor(attrobj))) {
			    %TypeError("The attributes given to defineProperty were inconsistent")
	    }
	    else {
		    %defineOwnProperty(obj, field, attrobj)
	    }
	}
    }	   
}

let [%defineProperty] = { [#code : %definePropertylambda,] }

let [%ObjectConstructor] = func(this, args) {
  let (calledAsFunction = this === undefined)
  let (hasArg = prim(">", args["length"], 0))
  let (notNull = prim("!", args["0"] === null))
  let (notUndefined = prim ("!", args["0"] === undefined))
  let (shouldReturnEarly =
    calledAsFunction && hasArg && notNull && notUndefined)
  let (defaultRtn = { [#proto : %ObjectProto,] })
  if (shouldReturnEarly) {
    %ToObject(args["0"])
  } else {
    if (hasArg) {
      let (argtype = prim("typeof", args["0"]))
      let (isArgObject = argtype === "object" || argtype === "function")
      let (isArgSomething = argtype === "boolean" ||
        argtype === "string" || argtype === "number")
      if (isArgObject) { args["0"] } else {
        if (isArgSomething) { %ToObject(args["0"]) } else { defaultRtn }
      }
    } else {
      defaultRtn
    }
  }
}

// Used internally
let [%mkArgsObjBase] = func(args) {
  let (keys = get-own-field-names(args)) {
  let (argsObj = {[#proto: %ObjectProto,
                   #class: "Arguments",
                   #extensible: true,]
                   "callee" : {#getter %ThrowTypeError, #setter %ThrowTypeError},
                   "caller" : {#getter %ThrowTypeError, #setter %ThrowTypeError}}) {
    argsObj["callee" <#configurable> = false];
    argsObj["caller" <#configurable> = false];
    rec (loop = func(iter) {
      let (strx = %ToString(iter))
      if (prim("hasOwnProperty", keys, strx)) {
        %defineOwnProperty(argsObj, strx, {
          []
          "value" : {#value args[strx], #writable false},
          "writable" : {#value true, #writable false},
          "configurable": {#value true, #writable false},
          "enumerable": {#value true, #writable false}
        });
        loop(prim("+", iter, 1))
      }
      else {
        %defineOwnProperty(argsObj, "length", {
          []
          "value" : {#value iter, #writable false},
          "writable" : {#value true, #writable false},
          "configurable": {#value true, #writable false},
          "enumerable": {#value false, #writable false}
        })
      }
    }) {
    loop(0);
    argsObj
    }
  }
  }
}

let [%mkArgsObj] = func(args) {
  let (argsObj = %mkArgsObjBase(args)) {
    argsObj["%new" = false];
    argsObj["%new"<#writable> = false];
    argsObj
  }
}

let [%mkNewArgsObj] = func(args) {
  let (argsObj = %mkArgsObjBase(args)) {
    argsObj["%new" = true];
    argsObj["%new"<#writable> = false];
    argsObj
  }
}

let [%oneArgObj] = func(arg) {
  %mkArgsObj({[] "0": {#value arg, #writable false},
                 "length" : {#value 1, #writable false}})
}

let [%twoArgObj] = func(arg1, arg2) {
  %mkArgsObj({[] "0": {#value arg1, #writable false},
                 "1": {#value arg2, #writable false},
                 "length" : {#value 2, #writable false}})
}

let [%calllambda] = func(this, args) {
  let (callArgs = %slice_internal(args, 1, %len(args))) {
    this(args["0"], callArgs)
  }
}

// http://es5.github.com/#x15.3.4.3
// 15.3.4.3 Function.prototype.apply (thisArg, argArray)
let [%applylambda] = func(this, args) {
  let (applyArgs = args["1"]) {
    if ((prim("typeof", applyArgs) === 'undefined') || 
        applyArgs === null) {
      applyArgs := {[]}
    } else { undefined };
    %ObjectTypeCheck(applyArgs);
    applyArgs := %mkArgsObj(applyArgs);
    this(args["0"], applyArgs)
  }
}


let [%call] = { [#code : %calllambda, #proto : %FunctionProto,] }
let [%apply] = { [#code : %applylambda, #proto : %FunctionProto,] }

{%defineOwnProperty(%FunctionProto,
  "call",
  {[] "value" : {#value %call, #writable true},
      "configurable": {#value true, #writable true},
      "writable": {#value true, #writable true}}) }

{%defineOwnProperty(%FunctionProto,
  "apply",
  {[] "value" : {#value %apply, #writable true},
      "configurable": {#value true, #writable true},
      "writable": {#value true, #writable true}}) }

let [%makeGetter] = func(object, id) {
  {[#code: func(this, args) {
    if (prim("hasProperty", object, id)) {
      object[id]
    } else {
      %UnboundId(id)
    }
  },
  #proto: %FunctionProto,
  #extensible: false,]}
}

let [%UnwritableDispatch] = func(id) {
  func(e) {
    if(e === 'unwritable-field') {
      %TypeError(prim("string+", id, " not writable"))
    }
    else { %ErrorDispatch(e) }
  }
}

let [%makeSetter] = func(object, id) {
  {[#code: func(this, args) {
//    object[id = args["0"]]
    try {
      object[id = args["0"]]
    } catch {
      %UnwritableDispatch(id)
    }
  },
  #proto: %FunctionProto,
  #extensible: false,]}
}

let [%primEach] = func(arr, fn) {
  rec (loop = func(i) {
    let (istr = %ToString(i))
    if(prim("hasOwnProperty", arr, istr)) {
      fn(arr[istr]);
      loop(prim("+", i , 1))
    } else {
      undefined
    }
  })
  loop(0)
}


let [%defineGlobalVar] = func(context, id) {
  if (prim("!", prim("hasProperty", context, id))) {
    %defineOwnProperty(%global,
      id,
      {[] "value" : {#value undefined, #writable true},
          "writable" : {#value true, #writable true},
          "enumerable": {#value true, #writable true},
          "configurable" : {#value false, #writable true}});
    %defineOwnProperty (context,
      id,
      {[] "get" : {#value %makeGetter(%global, id), #writable true},
          "set" : {#value %makeSetter(%global, id), #writable true},
          "enumerable" : {#value true, #writable false},
          "configurable" : {#value true, #writable false}})
  }
}


let [%defineGlobalAccessors] = func(context, id) {
  %defineOwnProperty (%globalContext,
    id,
    {[] "get" : {#value %makeGetter(%global, id), #writable true},
        "set" : {#value %makeSetter(%global, id), #writable true},
        "enumerable" : {#value true, #writable false},
        "configurable" : {#value true, #writable true}})    
}


let [%isNaN] = { [#code : %isNaNlambda, #proto : %FunctionProto,] }

let [%ErrorConstructor] = func(this, args) {
  let (o = {[#proto : %ErrorProto, #class : "Error",]})
  if (prim(">=", args["length"], 1)) {
    o["message" = %ToString(args["0"])];
    o
  } else { o }
}

let [%ErrorGlobalFuncObj] = 
  {[#code : %ErrorConstructor, #proto : %FunctionProto,]
   "prototype" : {#value %ErrorProto, #writable false}}

{%ErrorProto["constructor" = %ErrorGlobalFuncObj]}

let [%etslambda] = func(this, args) {
  if (prim("typeof", this) !== "object") {
    %TypeError("This not object in Error.prototype.toString")
  } else {
    let (name = if (this["name"] === undefined) { "Error" } else {
      %ToString(this["name"]) })
    let (msg = if (this["message"] === undefined) { "" } else {
      %ToString(this["message"]) })
    let (c1 = name === "")
    let (c2 = msg === "")
      label ret: {
	  if (c1 && c2) {
	      break ret "Error"
	  } else { null };
	  if (c1) {
	      break ret msg
	  } else { null };
	  if (c2) {
	      break ret name
	  } else { null };
	  
	  let (prefix = prim("string+", name, ": "))
	  break ret prim("string+", prefix, msg)
      }
  }
}

let [%ets] = {[#code : %etslambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%ErrorProto,
  "toString",
  {[] "value" : {#value %ets, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%NumberGlobalFuncObj] = 
  { [#code : %NumberConstructor, #proto : %FunctionProto,]
    "prototype" : {#value %NumberProto, #writable false},
    "MAX_VALUE" : {#value 1.79769313486231571e+308, #writable false},
    "MIN_VALUE" : {#value 5.0e-324, #writable false},
    "NaN" : {#value NaN, #writable false},
    "NEGATIVE_INFINITY" : {#value -inf, #writable false},
    "POSITIVE_INFINITY" : {#value +inf, #writable false},
    "length" : {#value 1, #writable false}}

{%NumberProto["constructor" = %NumberGlobalFuncObj]}

let [%stringToStringlambda] = func(this, args) {
  this[<#primval>]
}

let [%stringToString] = 
  { [#code : %stringToStringlambda, #proto : %FunctionProto,] 
    "length" : {#value 0, #writable false} }

{%defineOwnProperty(%StringProto,
  "toString",
  {[] "value" : {#value %stringToString, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%StringConstructor] = func(this, args) {
  let (S = if (args["length"] === 0) { "" } else { %ToString(args["0"]) })
  if (this === undefined) {
    // Called as function
    S
  } else {
    let (obj = 
      {[#proto : %StringProto, #primval : S, #class : "String",]
       "length" : {#value prim("strlen", S), #writable true}}) {
	    %StringIndices(obj, S);
	obj
    }
  }
}

let [%StringGlobalFuncObj] = 
  { [#code : %StringConstructor, #proto : %FunctionProto,]
    "length" : {#value 1, #writable false} }

let [%BooleanConstructor] = func(this, args) {
  let (b = %ToBoolean(args["0"]))
  if (this === undefined) {
    b
  } else {
    {[#proto : %BooleanProto, #class : "Boolean", #primval : b,]}
  }
}

let [%booleanToStringlambda] = func(this, args) {
  let (t = prim("typeof", this))
  let (b = if (t === "boolean") { this } else {
    if (t === "object") {
      if (this[<#class>] === "Boolean") {
        this[<#primval>]
      } else { %TypeError("Boolean.prototype.toString got non-boolean object")}
    } else { %TypeError(prim("string+", "Boolean.prototype.toString got ", t)) }
  })
  if (b) { "true" } else { "false" }
}

let [%booleanToString] = 
  { [#code : %booleanToStringlambda, #proto: %FunctionProto, #class: "Function",] }

{%define15Property(%booleanToString, "length", 0)}

{%define15Property(%BooleanProto, "toString", %booleanToString)}

let [%BooleanGlobalFuncObj] = { [#code : %BooleanConstructor, #proto : %FunctionProto,] } {
	%BooleanProto["constructor" = %BooleanGlobalFuncObj];
	%BooleanGlobalFuncObj["length" = 1]
}

{%defineOwnProperty(%BooleanGlobalFuncObj,
  "prototype",
  {[] "value" : {#value %BooleanProto, #writable true},
      "configurable" : {#value false, #writable true}}) }

{%StringProto["constructor" = %StringGlobalFuncObj];
 %StringGlobalFuncObj["prototype" = %StringProto];
 %StringGlobalFuncObj["prototype"<#enumerable> = false];
 %StringGlobalFuncObj["prototype"<#writable> = false];
 %StringGlobalFuncObj["prototype"<#configurable> = false] }

 let [%ObjectGlobalFuncObj] = 
  { [#code : %ObjectConstructor, #proto : %FunctionProto,] 
    "prototype" : {#value %ObjectProto, #writable false},
    "length" : {#value 1, #writable false},
  } {
	  %ObjectProto["constructor" = %ObjectGlobalFuncObj];
	  %ObjectProto["constructor"<#enumerable> = false]
  }

let [%gpoLambda] = func(this, args) {
  let (O = args["0"]) {
     %ObjectTypeCheck(O);
     O[<#proto>]
  }
}

let [%gpo] = {[#code : %gpoLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%ObjectGlobalFuncObj,
  "getPrototypeOf",
  {[] "value" : {#value %gpo, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%gopdLambda] = func(this, args) {
  let (O = args["0"]) {
      %ObjectTypeCheck(O);
      let (name = %ToString(args["1"]))

      label ret: {
	  if (prim("!", prim("hasOwnProperty", O, name))) {
	      break ret undefined
	  } else { null };
	  
	  let (obj = {[#proto : %ObjectProto,]}) {
	      %defineOwnProperty(obj,
				 "enumerable",
				 {[] "value" : {#value O[name<#enumerable>], #writable true},
				  "writable" : {#value true, #writable true},
				  "enumerable" : {#value true, #writable true},
				  "configurable" : {#value true, #writable true}});
	      %defineOwnProperty(obj,
				 "configurable",
				 {[] "value" : {#value O[name<#configurable>], #writable true},
				  "writable" : {#value true, #writable true},
				  "enumerable" : {#value true, #writable true},
				  "configurable" : {#value true, #writable true}});
	  
	      if (prim("!", prim("isAccessor", O, name))) {
		      %defineOwnProperty(obj,
					 "value",
					 {[] "value" : {#value O[name], #writable true},
					  "writable" : {#value true, #writable true},
					  "enumerable" : {#value true, #writable true},
					  "configurable" : {#value true, #writable true}});
		      %defineOwnProperty(obj,
					 "writable",
					 {[] "value" : {#value O[name<#writable>], #writable true},
					  "writable" : {#value true, #writable true},
					  "enumerable" : {#value true, #writable true},
					  "configurable" : {#value true, #writable true}});
		  break ret obj
	      } else {
		      %defineOwnProperty(obj,
					 "get",
					 {[] "value" : {#value O[name<#getter>], #writable true},
					  "writable" : {#value true, #writable true},
					  "enumerable" : {#value true, #writable true},
					  "configurable" : {#value true, #writable true}});
		      %defineOwnProperty(obj,
					 "set",
					 {[] "value" : {#value O[name<#setter>], #writable true},
					  "writable" : {#value true, #writable true},
					  "enumerable" : {#value true, #writable true},
					  "configurable" : {#value true, #writable true}});
		  break ret obj
	      }
	  }
      }
  }
}

let [%gopd] = {[#code : %gopdLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%ObjectGlobalFuncObj,
  "getOwnPropertyDescriptor",
  {[] "value" : {#value %gopd, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%objectToStringlambda] = func(this, args) {
    label ret: {
	if (this === undefined) {
	    break ret "[object Undefined]"
	} else { undefined };
	
	if (this === null) {
	    break ret "[object Null]"
	} else { undefined };
	
	let (O = %ToObject(this))
	let (class = O[<#class>])
	break ret prim("string+", "[object ", prim("string+", class, "]"))
    }
}

let [%objectToString] = 
  { [#code : %objectToStringlambda, #proto : %FunctionProto,] 
    "length" : {#value 0, #writable false} }

let [%propEnumlambda] = func(this, args) {
  let (getOwnProperty = func(o, f) {
    if (prim("hasOwnProperty", o, f)) { o[f] } else { undefined }})
  if (args["0"] === undefined) { false } else {
  let (P = %ToString(args["0"]))
  let (O = %ToObject(this))
  let (desc = getOwnProperty(O, P))
  if (desc === undefined) {
    false
  } else { 
    O[P<#enumerable>] 
  }}
}

let [%propertyIsEnumerable] = 
  {[#code : %propEnumlambda, #proto : %FunctionProto,]
    "length" : {#value 1, #writable false} }

let [%toLocaleStringlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (toString = O["toString"])
  if (toString[<#code>] === null) {
    %TypeError("toLocaleString")
  } else {
    toString(O, {[]})
  }
}

let [%toLocaleString] = 
  { [#code : %toLocaleStringlambda, #proto : %FunctionProto,] 
    "length" : {#value 0, #writable false} }

let [%valueOflambda] = func(this, args) {
  %ToObject(this)
}

let [%valueOf] = 
  { [#code : %valueOflambda, #proto : %FunctionProto,] 
    "length" : {#value 0, #writable false}
  }


let [%hasOwnPropertylambda] = func(this, args) {
    if(prim("hasOwnProperty", this, args["0"])) {
      true
    }
    else {
      false
    }
}

let [%hasOwnProperty] = 
  { [#code : %hasOwnPropertylambda, #proto : %FunctionProto,] 
    "length" : {#value 1, #writable false}
  }


let [%IsPrototypeOflambda] = func(this, args) {
    rec (searchChain = func(o, v) {
      let (vproto = v[<#proto>])
      if (vproto === null) {
        false
      } else {
        if (o === vproto) {
          true
        } else {
          searchChain(o, vproto) 
        }
      }
    })
    let (vtype = prim("typeof", args["0"]))
    if (prim("!", vtype === "object") && prim("!", vtype === "function")) {
      false
    } else {
      let (O = %ToObject(this))
      searchChain(O, args["0"])
    }
}

let [%isPrototypeOf] = 
  { [#code : %IsPrototypeOflambda, #proto : %FunctionProto,]
    "length" : {#value 1, #writable false}
  } { 
  %ObjectProto["toString" = %objectToString];
  %ObjectProto["toString"<#writable> = true];
  %ObjectProto["toString"<#enumerable> = false];

  %ObjectProto["toLocaleString" = %toLocaleString];
  %ObjectProto["toLocaleString"<#writable> = false];
  %ObjectProto["toLocaleString"<#enumerable> = false];

  %ObjectProto["valueOf" = %valueOf];
  %ObjectProto["valueOf"<#writable> = true];
  %ObjectProto["valueOf"<#enumerable> = false];

  %ObjectProto["hasOwnProperty" = %hasOwnProperty];
  %ObjectProto["hasOwnProperty"<#writable> = false];
  %ObjectProto["hasOwnProperty"<#enumerable> = false];

  %ObjectProto["isPrototypeOf" = %isPrototypeOf];
  %ObjectProto["isPrototypeOf"<#writable> = false];
  %ObjectProto["isPrototypeOf"<#enumerable> = false]
}

{(/*:START SYM EVAL*/0)}

{(/*:STOP SYM EVAL*/0)}

let [%NativeErrorConstructor] = func(proto) {
  func(this, args) {
    let (rtn = { [#proto : proto, #class : "Error",] })
    if (args["0"] !== undefined) {
      rtn["message" = %ToString(args["0"])];
      rtn
    } else {
      rtn
    }
  }
}

{%defineOwnProperty(%SyntaxErrorProto,
  "name",
  {[] "value" : {#value "SyntaxError", #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%SyntaxErrorConstructor] = %NativeErrorConstructor(%SyntaxErrorProto)

let [%SyntaxErrorGlobalFuncObj] = 
  { [#code : %SyntaxErrorConstructor, #proto : %SyntaxErrorProto,] 
    "prototype" : {#value %SyntaxErrorProto, #writable false} }

{%SyntaxErrorProto["constructor" = %SyntaxErrorGlobalFuncObj]}

{(/*:START SYM EVAL*/0)}

let [%RangeErrorProto] = 
  { [#proto : %ErrorProto,] 
    "name" : {#value "RangeError", #writable false}}

{(/*:STOP SYM EVAL*/0)}

let [%RangeErrorConstructor] = %NativeErrorConstructor(%RangeErrorProto)

let [%RangeErrorGlobalFuncObj] = 
  { [#code : %RangeErrorConstructor, #proto : %RangeErrorProto,] 
    "prototype" : {#value %RangeErrorProto, #writable false} }

{%RangeErrorProto["constructor" = %RangeErrorGlobalFuncObj]}

{%defineOwnProperty(%ReferenceErrorProto,
  "name",
  {[] "value" : {#value "ReferenceError", #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%ReferenceErrorConstructor] = %NativeErrorConstructor(%ReferenceErrorProto)

let [%ReferenceErrorGlobalFuncObj] = 
  { [#code : %ReferenceErrorConstructor, #proto : %ReferenceErrorProto,] 
    "prototype" : {#value %ReferenceErrorProto, #writable false} }

{%ReferenceErrorProto["constructor" = %ReferenceErrorGlobalFuncObj]}

{%defineOwnProperty(%TypeErrorProto,
  "name",
  {[] "value" : {#value "TypeError", #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%TypeErrorConstructor] = %NativeErrorConstructor(%TypeErrorProto)

let [%TypeErrorGlobalFuncObj] = 
  { [#code : %TypeErrorConstructor, #proto : %TypeErrorProto,] 
    "prototype" : {#value %TypeErrorProto, #writable false} }

{%TypeErrorProto["constructor" = %TypeErrorGlobalFuncObj]}

{(/*:START SYM EVAL*/0)}

let [%URIErrorProto] = 
  { [#proto : %ErrorProto,]
    "name" : {#value "URIError", #writable false}}

{(/*:STOP SYM EVAL*/0)}

let [%URIErrorConstructor] = %NativeErrorConstructor(%URIErrorProto)

let [%URIErrorGlobalFuncObj] = 
  { [#code : %URIErrorConstructor, #proto : %FunctionProto,]
    "prototype" : {#value %URIErrorProto, #writable false} }

{%URIErrorProto["constructor" = %URIErrorGlobalFuncObj]}

{(/*:START SYM EVAL*/0)}

let [%ArrayProto] = { [#proto : %ObjectProto, #class : "Array",]
  "length" : {#value 0, #writable true} }

{(/*:STOP SYM EVAL*/0)}

let [%gopnLambda] = func(this, args) {
  let (O = args["0"]) {
      %ObjectTypeCheck(O);
      let (A = 
	   {[#proto : %ArrayProto, #class : "Array",] 
            "length" : {#value 0, #writable true}})
      let (props = get-own-field-names(O))
      let (len = props["length"])
      rec (loop = func(i) {
	  if (prim("<", i, len)) {
	      let (to = prim("prim->str", i))
	      let (from = prim("prim->str", prim("-", len, prim("+", i, 1))))
	      A[to = props[from] ];
	      loop(prim("+", i, 1))
	  } else {
	      A["length" = i]
	  }
      }) {
	  loop(0);
	  A
      }
  }
}

let [%gopn] = {[#code : %gopnLambda, #proto : %FunctionProto,]}

{%define15Property(%ObjectGlobalFuncObj, "getOwnPropertyNames", %gopn)}

{%define15Property(%ObjectGlobalFuncObj, "defineProperty", %defineProperty)}

let [%definePropertiesLambda] = func(this, args) {
  let (O = args["0"]) {
	  %ObjectTypeCheck(O);
      let (props = %ToObject(args["1"]))
      let (names = get-own-field-names(props))
      let (len = names["length"])
      rec (loop = func(i) {
	  label ret: {
	      if (prim("<", i, len)) {
		  let (indx = prim("prim->str", i))
		  let (name = names[indx])
		  if (props[name<#enumerable>]) {
		      let (argsObj = {[]}) {
			  argsObj["0" = O];
			  argsObj["1" = name];
			  argsObj["2" = props[name] ];
			  argsObj["length" = 3];
			      %definePropertylambda(null, argsObj);
			  break ret loop(prim("+", i, 1))
		      }
		  } else {
		      break ret loop(prim("+", i, 1))
		  }
	      } else { break ret undefined }
	  }})
      loop(0);
      O
  }
}

let [%defineProperties] = 
  {[#code : %definePropertiesLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%ObjectGlobalFuncObj,
  "defineProperties",
  {[] "value" : {#value %defineProperties, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%createLambda] = func(this, args) {
  let (O = args["0"])
  let (t = prim("typeof", O))
  let (c1 = t !== "object")
  let (c2 = t !== "function")
    let (c3 = O !== null) {
	
	if (c1 && c2 && c3) {
    %TypeError("Object.create failed")
	} else { null };

	let (obj = {[#proto : O,]}) {
	    if (prim(">=", args["length"], 2) && args["1"] !== undefined) {
		let (Properties = %ToObject(args["1"]))
		let (argsObj = {[]}) {
		    argsObj["0" = obj];
		    argsObj["1" = Properties];
		    argsObj["length" = 2];
		    %definePropertiesLambda(null, argsObj);
		    obj
		}
	    } else {
		obj
	    }
	}
    }
}

let [%create] = {[#code : %createLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%ObjectGlobalFuncObj,
  "create",
  {[] "value" : {#value %create, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%sealLambda] = func(this, args) {
    let (O = args["0"]) {
	    %ObjectTypeCheck(O);
	
	let (names = get-own-field-names(O))
	let (len = names["length"])
	rec (loop = func(i) {
	    if (prim("<", i, len)) {
		let (name = names[prim("prim->str", i)])
		O[name<#configurable> = false];
		loop(prim("+", i, 1))
	    } else { null }
	})
	loop(0);
	O[<#extensible>=false];
	O
    }
}

let [%seal] = {[#code : %sealLambda, #proto : %FunctionProto,]}

{%define15Property(%ObjectGlobalFuncObj, "seal", %seal)}

let [%freezelambda] = func(this, args) {
  let (O = args["0"]) {
      %ObjectTypeCheck(O);

      let (names = get-own-field-names(O))
      let (len = names["length"])
      rec (loop = func(i) {
	  if (prim("<", i, len)) {
	      let (name = names[prim("prim->str", i)]) {
		  if (prim("!", prim("isAccessor", O, name))) {
		      if (O[name<#writable>]) {
			  O[name<#writable> = false]
		      }
		  };
		  
		  O[name<#configurable> = false];
		  loop(prim("+", i, 1))
	      }
	  } else { null }
      }) {
	  loop(0);
	  O[<#extensible> = false];
	  O
      }
  }
}

let [%freeze] = {[#code : %freezelambda, #proto : %FunctionProto,]}

{%define15Property(%ObjectGlobalFuncObj, "freeze", %freeze)}

let [%preventExtensionsLambda] = func(this, args) {
    let (O = args["0"]) {
	    %ObjectTypeCheck(O);
	O[<#extensible> = false];
	O
    }
}

let [%preventExtensions] = 
  {[#code : %preventExtensionsLambda, #proto : %FunctionProto,]}

{%define15Property(%ObjectGlobalFuncObj, "preventExtensions", %preventExtensions)}

let [%isFrozenLambda] = func(this, args) {
    let (O = args["0"]) {
	    %ObjectTypeCheck(O);
	let (names = get-own-field-names(O))
	let (len = names["length"])
	rec (loop = func(i) {
	    label ret: {
		if (prim("<", i, len)) {
		    let (name = names[prim("prim->str", i)])
		    let (isData = prim("!", prim("isAccessor", O, name))) {
		    
		    if (isData && O[name<#writable>]) {
			break ret false
		    } else { null };
		    
		    if (O[name<#configurable>]) {
			break ret false
		    } else { null };
		    
		    break ret loop(prim("+", i, 1))
      }
		} else { break ret prim("!", O[<#extensible>]) }
	    }})
	loop(0)
    }
}

let [%isFrozen] = {[#code : %isFrozenLambda, #proto : %FunctionProto,]}

{%define15Property(%ObjectGlobalFuncObj, "isFrozen", %isFrozen)}

let [%isSealedLambda] = func(this, args) {
    let (O = args["0"]) {
	    %ObjectTypeCheck(O);
	let (names = get-own-field-names(O))
	let (len = names["length"])
	rec (loop = func(i) {
	    label ret: {
		if (prim("<", i, len)) {
		    let (name = names[prim("prim->str", i)])
		    if (O[name<#configurable>]) {
			break ret false
		    } else { null };
		    break ret loop(prim("+", i, 1))
		} else { break ret prim("!", O[<#extensible>]) }
	    }})
	loop(0)
    }
}

let [%isSealed] = {[#code : %isSealedLambda, #proto : %FunctionProto,]}

{%define15Property(%ObjectGlobalFuncObj, "isSealed", %isSealed)}

let [%isExtensibleLambda] = func(this, args) {
    let (O = args["0"]) {
	    %ObjectTypeCheck(O);
	O[<#extensible>]
    }
}

let [%isExtensible] = {[#code : %isExtensibleLambda, #proto : %FunctionProto,]}

{%define15Property(%ObjectGlobalFuncObj, "isExtensible", %isExtensible)}

let [%propertyNames] = func(obj, get-non-enumerable) {
  let (aux = {[#extensible : true,]})
  rec (helper = func(obj) {
    if (obj === null) {
      undefined
    } else {
      let (cur = get-own-field-names(obj))
      let (length = cur["length"])
      rec (loop = func(i) {
        if (prim("<", i, length)) { 
          let (istr = prim("prim->str",i)) {
            if (obj[cur[istr]<#enumerable>] || get-non-enumerable) {
              aux[cur[istr] = true]
            } else {undefined };
            loop(prim("+",i,1)) 
          }
        }
        else { undefined }
      })
      loop(0);
      helper(obj[<#proto>])
    }
  }) {
    helper(obj);
    get-own-field-names(aux)
  }
}

let [%keysLambda] = func(this, args) {
    let (O = args["0"]) {
	    %ObjectTypeCheck(O);

	let (A = 
	     {[#proto : %ArrayProto, #class : "Array",] 
              "length" : {#value 0, #writable true}})
	let (names = get-own-field-names(O))
	let (len = names["length"])
	
	rec (loop = func(i, enumCount) {
	    if (prim("<", i, len)) {
		let (indx = prim("prim->str", i))
		let (name = names[indx])
		if (O[name<#enumerable>]) {
		    let (pd = {[] "value" : {#value name, #writable true},
			       "writable" : {#value true, #writable true},
			       "enumerable" : {#value true, #writable true},
			       "configurable" : {#value true, #writable true}})
			%defineOwnProperty(A, prim("prim->str", enumCount), pd);
		    loop(prim("+", i, 1), prim("+", enumCount, 1))
		} else {
		    loop(prim("+", i, 1), enumCount)  
		}
	    } else { A["length" = enumCount] }
	}) {
	    loop(0, 0);
	    A
	}
    }
}

let [%keys] = {[#code : %keysLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%ObjectGlobalFuncObj,
  "keys",
  {[] "value" : {#value %keys, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%ToUint] = func(n, limit) {
  let (number = %AssertNumber(n))
  if (number !== number || number === 0 || number === +inf || number === -inf) { 
    0 
  } else {
    let (sign = if (prim("<", number ,0)) { prim("-", 0, 1) } else { 1 })
    let (posInt = prim("*", sign, prim("floor", prim("abs", number))))
    if (prim("<", sign, 0)) {
      let (close = prim("%", posInt, limit))
      prim("+", close, limit)
    } else { 
      prim("%", posInt, limit)
    }
  }
}

let [%ToUint32] = func(n) {
  %ToUint(n, 4294967296.0)
}

let [%ToInt32] = func(n) {
  let (int32bit = %ToUint32(n))
  if (prim(">=", int32bit, 2147483648.0)) {
    prim("-", int32bit, 4294967296.0)
  } else {
    int32bit
  }
}

let [%ToUint16] = func(n) {
  %ToUint(n, 65536.0)
}

let [%fromcclambda] = func(this, args) {
  if (args["length"] === 0) {
    ""
  } else {
    let (end = args["length"])
    rec (loop = func(i, soFar) {
      if (prim("<", i, end)) {
        let (char = prim("ascii_ntoc", %ToUint16(args[prim("prim->str", i)])))
        let (next = prim("string+", soFar, char))
        loop(prim("+", i, 1), next)
      } else { soFar }
    })
    loop(0, "")
  }
}

let [%fromCharCode] = 
  {[#code : %fromcclambda, #proto : %FunctionProto,]
    "length" : {#value 1, #writable false}}

{%defineOwnProperty(%StringGlobalFuncObj,
  "fromCharCode",
  {[] "value" : {#value %fromCharCode, #writable true},
      "configurable" : {#value true, #writable true},
      "writable" : {#value true, #writable true}}) }

let [%joinlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (sep = if (args["0"] === undefined) { "," } 
    else { %ToString(args["0"]) })
    label ret: {
	if (len === 0) {
	    break ret ""
	} else { null };
	rec (loop = func(k, R) {
	    if (prim(">=", k, len)) {
		R
	    } else {
		let (S = prim("string+", R, sep))
		let (element = O[%ToString(k)])
		let (next =
		     if (element === null || element === undefined) { "" }
		     else { %ToString(element) })
		loop(prim("+", k, 1), prim("string+", S, next)) 
	    }
	})
	let (start = if (O["0"] === undefined || O["0"] === null) { "" }
	     else { %ToString(O["0"]) })
	break ret loop(1, start)
    }
}

let [%join] = { [#code : %joinlambda, #proto : %FunctionProto,] }

{%defineOwnProperty(%join, 
    "length", 
    {[] "value" : {#value 1, #writable true}, 
        "configurable" : {#value false, #writable true},
        "enumerable" : {#value false, #writable true}})}

let [%poplambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  if (len === 0) {
    O["length" = 0];
    undefined
  } else {
    let (indx = %ToString(prim("-", len, 1)))
      let (element = O[indx]) {
	  O[delete indx];
	  O["length" = %ToNumber(indx)];
	  element
      }
  }
}

let [%pop] = { [#code : %poplambda, #proto : %FunctionProto,] }

{%defineOwnProperty(%pop,
  "length",
  {[] "value" : {#value 0, #writable true},
      "configurable" : {#value false, #writable true}})}

{%defineOwnProperty(%ArrayProto,
  "pop",
  {[] "value" : {#value %pop, #writable true},
      "configurable" : {#value true, #writable true}})}

let [%ArrayLengthChange] = func(arr, newlen) {
  let (oldlen = %ToUint32(arr["length"]))
  rec (fix = func(i) {
    if (prim("<", i, oldlen)) {
      arr[delete prim("prim->str", i)];
      fix(prim("+", i, 1))
    }
  })
  fix(newlen)
}

// 15.4: A property name P (in the form of a String value) is an array index if and
// only if ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal to
// 2^32-1
let [%set-property] = func(obj, fld, val) {
  let (obj = %ToObject(obj))
  let (fld = %ToString(fld))

  let (check = func(flag) {
    if (flag) {
      %TypeError("set-property failed")
    } else { null }
  })

  let (e = prim("!", obj[<#extensible>])) {
  check(e);

  let (isArrayIndex = func() {
    let (uint = %ToUint32(fld))
      if (%ToString(uint) === fld) {
        uint !== 4294967295.0
      }
      else {
        false
      }
  })
  let (setArrayField = func() {
    let (lenCheck = func() {
      if (fld === "length") {
        let (newLen = %ToUint32(val))
        let (toCompare = %ToNumber(val))
        if (newLen !== toCompare) {
          throw %JSError({[#proto : %RangeErrorProto,]})
        } else {
          if (prim("<", newLen, obj["length"])) {
            %ArrayLengthChange(obj, newLen)
          } else { undefined }
        }
      } else { undefined }
    }) {
    lenCheck();

    obj[fld = if (fld === "length") { %ToUint32(val) } else { val }];

    if (isArrayIndex()) {
      let (uint = %ToUint32(fld))
      let (len = obj["length"])
      if (prim("<", len, prim("+", uint, 1))) {
        obj["length" = prim("+", uint, 1)]
      } else { undefined }
    }
    else { undefined }
    }})
  if (obj[<#class>] === "Array") {
    setArrayField()
  }
  else {
    obj[fld = val]
  }
  }
}

let [%pushlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  rec (loop = func(i, n) {
    if (prim("<", i, args["length"])) {
      let (ii = prim("prim->str", i))
      %set-property(O, %ToString(n), args[ii]);
      //O[%ToString(n) = args[ii] ];
      loop(prim("+", i, 1), prim("+", n, 1))
    } else { n }
  })
  loop(0, len)
}

let [%push] = {[#code : %pushlambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%push,
  "length",
  {[] "value" : {#value 1, #writable true},
      "configurable" : {#value false, #writable true}})}

{%defineOwnProperty(%ArrayProto,
  "push",
  {[] "value" : {#value %push, #writable true},
      "configurable" : {#value true, #writable true}})}

let [%reverselambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (middle = prim("floor", prim("/", len, 2)))
  rec (loop = func(lower) {
    if (lower !== middle) {
	label ret: {
	    let (upper = prim("-", prim("-", len, lower), 1))
	    let (upperP = %ToString(upper))
	    let (lowerP = %ToString(lower))
	    let (lowerValue = O[lowerP])
	    let (upperValue = O[upperP])
	    let (lowerExists = prim("hasProperty", O, lowerP))
	    let (upperExists = prim("hasProperty", O, upperP))
	    
	    if (lowerExists && upperExists) {
		O[lowerP = upperValue];
		O[upperP = lowerValue];
		break ret loop(prim("+", lower, 1))
	    } else { null };
	    
	    if (upperExists) {
		O[lowerP = upperValue];
		O[delete upperP];
		break ret loop(prim("+", lower, 1))
	    } else { null };
	    
	    if (lowerExists) {
		O[delete lowerP];
		O[upperP = lowerValue];
		break ret loop(prim("+", lower, 1))
	    } else { null };
	    
	    break ret loop(prim("+", lower, 1))
	}
    }
  }) {
      loop(0);
      O
  }
}

let [%reverse] = {[#code : %reverselambda, #proto : %FunctionProto,]}

{ %defineOwnProperty(%reverse,
  "length",
  {[] "value" : {#value 0, #writable true},
      "configurable" : {#value false, #writable true}}) }

{ %defineOwnProperty(%ArrayProto,
  "reverse",
  {[] "value" : {#value %reverse, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%shiftlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  if (len === 0) {
    O["length" = 0];
    undefined
  } else { 
    let (first = O["0"])
    rec (loop = func(k) {
	label ret: {
	    if (prim(">=", k, len)) {
		break ret undefined
	    } else { null };
	    
	    let (from = %ToString(k))
	    let (to = %ToString(prim("-", k, 1)))
	    let (fromPresent = prim("hasProperty", O, from))
	    if (fromPresent) {
		let (fromVal = O[from])
		O[to = fromVal];
		break ret loop(prim("+", k, 1))
	    } else {
		O[delete to];
		break ret loop(prim("+", k, 1))
	    }
	}})
    loop(1);
    let (newLen = prim("-", len, 1))
    O[delete %ToString(newLen)];
    O["length" = newLen];
    first
  }
}

let [%shift] = {[#code : %shiftlambda, #proto : %FunctionProto,]}

{ %defineOwnProperty(%shift,
  "length",
  {[] "value" : {#value 0, #writable true},
      "configurable" : {#value false, #writable true}}) }

{ %defineOwnProperty(%ArrayProto,
  "shift",
  {[] "value" : {#value %shift, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%arrayToStringlambda] = func(this, args) {
  let (array = %ToObject(this))
  let (thefunc = array["join"])
  let (ffunc = 
  if (prim("!", prim("typeof", thefunc) === "object") &&
      prim("!", prim("typeof", thefunc) === "function")) {
    %objectToStringlambda
  } else {
    if (thefunc[<#code>] === null) {
      %objectToStringlambda
    } else { thefunc }
  })
  ffunc(array, {[]})
}

let [%arrayToString] = 
  { [#code : %arrayToStringlambda, #proto : %FunctionProto,] 
    "length" : {#value 0, #writable false} }

{ %defineOwnProperty(%ArrayProto, 
    "toString", 
    {[] "value" : {#value %arrayToString, #writable true}, 
        "writable" : {#value true, #writable true},
        "configurable" : {#value true, #writable true}});
  %defineOwnProperty(%ArrayProto,
    "join",
    {[] "value" : {#value %join, #writable true},
        "configurable" : {#value true, #writable true}}) }

let [%arrayTLSlambda] = func(this, args) {
  let (isCallable = func(o) {
      label ret: {
	  if (prim("!", prim("typeof", o) === "object") &&
              prim("!", prim("typeof", o) === "function")) {
	      break ret false 
	  } else { null };
	  if (o[<#code>] === null) {
	      break ret false
	  } else { null };
	  break ret true
      }})
  let (array = %ToObject(this))
  let (arrayLen = array["length"])
  let (len = %ToUint32(arrayLen))
  let (separator = " ")
    label ret: {
	if (len === 0) {
	    break ret ""
	} else { null };
	let (firstElement = array["0"])
	let (R = if (firstElement === null || firstElement === undefined) { "" } else {
	    let (elementObj = %ToObject(firstElement))
	    let (funcc = elementObj["toLocaleString"])
	    if (prim("!", isCallable(funcc))) {
        %TypeError("Not callable in ArrayTLS")
      }
	    else { null };
	    funcc(elementObj, {[]}) })
	rec (inner = func(k, r) {
	    if (prim(">=", k, len)) {
		r
	    } else {
		let (S = prim("string+", prim("prim->str", r), separator))
		let (nextElement = array[prim("prim->str", k)])
		let (toAppend = if (nextElement === null ||
				    nextElement === undefined) { "" } else {
					let (elementObj = %ToObject(nextElement))
					let (funcc = elementObj["toLocaleString"]) {
					    if (prim("!", isCallable(funcc))) {
						throw %JSError({[#proto : %TypeErrorProto,]})
					    } else { null };
					    funcc(elementObj, {[]}) }})
		inner(prim("+", k, 1), 
		      prim("string+", prim("prim->str", r),
			   prim("prim->str", toAppend)))
	    }
	})
	break ret inner(1, R)
    }
}

let [%arrayToLocaleString] = 
  { [#code : %arrayTLSlambda, #proto : %FunctionProto,]
    "length" : {#value 0, #writable false} }

{ %defineOwnProperty(%ArrayProto, 
    "toLocaleString", 
    {[] "value" : {#value %arrayToLocaleString, #writable true}, 
        "configurable" : {#value true, #writable true}}) }

let [%ArrayConstructor] = func(this, args) {
    label ret: {
	if (prim(">=", args["length"], 2)) {
	    let (rtnobj = 
		 {[#proto : %ArrayProto, #class : "Array",] 
		  "length" : {#value 0, #writable true}, })
	    rec (init = func(n) {
		rtnobj[ prim("prim->str", n) = args[prim("prim->str", n)] ];
		if (prim(">", n, 0)) {
		    init(prim("-", n, 1))
		}
	    }) {
		init(args["length"]);
		rtnobj["length" = args["length"] ];
		break ret rtnobj
	    }
	} else { null };
	let (c1 = prim("typeof", args["0"]) === "number")
	let (c2 = if (c1) { %ToUint32(args["0"]) !== args["0"] } else { false })
	if (c2) {
	    throw %JSError({[#proto : %RangeErrorProto,]})
	} else {
	    if (c1) {
		break ret { [#proto : %ArrayProto, #class : "Array",]
			    "length" : {#value %ToUint32(args["0"]), #writable true} }
	    } else {
		let (rtn = {[#proto : %ArrayProto, #class : "Array",]
			    "length" : {#value args["length"], #writable true}}) {
		    %defineOwnProperty(rtn,
				       "0",
				       {[] "value" : {#value args["0"], #writable true},
					"writable" : {#value true, #writable true},
					"enumerable" : {#value true, #writable true},
					"configurable" : {#value true, #writable true}});
		    break ret rtn
		}
	    }
	}
    }
}

let [%concatLambda] = func(this, args) {
  let (O = %ToObject(this))
  let (emptyobj = {[]})
  let (A = %ArrayConstructor(emptyobj, emptyobj))
  rec (procElt = func(obj, elt, n) {
    let (procNormalElt = func(nelt, k) {
      obj[prim("prim->str", k) = nelt];
      prim("+", k, 1)
    })
    rec (procArrayElt = func(arr, fromIndex, toIndex) {
      if (arr[prim("prim->str", fromIndex)] === undefined) {
        toIndex
      } else {
        obj[prim("prim->str", toIndex) = arr[prim("prim->str", fromIndex)] ];
        procArrayElt(arr, prim("+", fromIndex, 1), prim("+", toIndex, 1))
      }
    })
    if (prim("typeof", elt) === "object") {
      if (elt[<#class>] === "Array") {
        procArrayElt(elt, 0, n)
      } else {
        procNormalElt(elt, n)
      }
    } else {
      procNormalElt(elt, n)
    }
  })
  rec (procAllElts = func(from, fromIndex, toIndex) {
    if (from[prim("prim->str", fromIndex)] !== undefined) {
      let (nextI = procElt(A, from[prim("prim->str", fromIndex)], toIndex))
      procAllElts(from, prim("+", fromIndex, 1), nextI)
    } else { toIndex }
  })
  let (halftime = if (O[<#class>] === "Array") {
    procAllElts(O, 0, 0) } else { A["0" = O]; 1 })
    let (end = procAllElts(args, 0, halftime)) {
	A["length" = end];
	A
    }
}

let [%concat] = 
  { [#code : %concatLambda, #proto : %FunctionProto,] }

{ %defineOwnProperty(%concat,
    "length",
    {[] "value" : {#value 1, #writable true},
        "enumerable" : {#value false, #writable true}})}

{ %defineOwnProperty(%ArrayProto,
    "concat",
    {[] "value" : {#value %concat, #writable true}})}

let [%sortlambda] = func(this, args) {
  let (obj = %ToObject(this))
  let (sortCompare = func(j, k) {
    let (jString = %ToString(j))
    let (kString = %ToString(k))

    let (hasj = prim("hasProperty", obj, jString))
    let (hask = prim("hasProperty", obj, kString))
      label ret: {
	  if (hasj === false && hask === false) {
	      break ret 0
	  } else { null };
	  
	  if (hasj === false) {
	      break ret 1
	  } else { null };
	  
	  if (hask === false) {
	      break ret prim("-", 0, 1)
	  } else { null };
	  
	  let (x = obj[jString])
	  let (y = obj[kString]) {
	      if (x === undefined && y === undefined) {
		  break ret 0
	      } else { null };
	      
	      if (x === undefined) {
		  break ret 1
	      } else { null };
	  
	      if (y === undefined) {
		  break ret prim("-", 0, 1)
	      } else { null };
	  
	      if (args["0"] !== undefined) {
		  if (prim("typeof", args["0"]) !== "function") {
		      throw %JSError({[#proto : %TypeErrorProto,]})
		  } else { null };
		  
		  break ret args["0"](undefined, 
				      {[] "0" : {#value x, #writable true},
				       "1" : {#value y, #writable true}})
	      } else { null };
	      
	      let (xString = %ToString(x))
	      let (yString = %ToString(y)) {
	      
		  if (prim("string<", xString, yString)) {
		      break ret prim("-", 0, 1)
		  } else { null };
		  
		  if (prim("string<", yString, xString)) {
		      break ret 1
		  } else { null };
		  break ret 0
	      }
	  }
      }})

  let (insert = func(elt, before) {
    rec (insertAndShift = func(prior, i) {
      let (indx = prim("prim->str", i))
	let (next = obj[indx]) {
	    obj[indx = prior];
	    if (prim("<", i, before)) {
		insertAndShift(next, prim("+", i, 1))
	    } else { undefined }
	}
    })

    rec (loop = func(currIndex) {
      if (currIndex === before) {
        // elt can stay where it was
        undefined
      } else {
        let (indx = prim("prim->str", currIndex))
        let (result = sortCompare(currIndex, before))
        if (result === 1) {
          let (old = obj[indx]) {
            obj[indx = elt];
            insertAndShift(old, prim("+", currIndex, 1))
          }
        } else {
          loop(prim("+", currIndex, 1))
        }
      }
    })

    loop(0)
  }) 
  let (len = obj["length"])
  rec (isort = func(i) {
    if (prim("<", i, len)) {
      insert(obj[prim("prim->str", i)], i);
      isort(prim("+", i, 1))
    } else { obj }
  })

  isort(1)
}

let [%sort] = { [#code : %sortlambda, #proto : %FunctionProto,] }

{%defineOwnProperty(%sort,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%define15Property(%ArrayProto, "sort", %sort)}

let [%ArrayGlobalFuncObj] = 
  { [#code : %ArrayConstructor, #proto : %FunctionProto, #class : "Function",] 
    "prototype" : {#value %ArrayProto, #writable false} }

{ %ArrayGlobalFuncObj["length" = 1];
  %ArrayGlobalFuncObj["length"<#enumerable> = false];
  %ArrayGlobalFuncObj["length"<#configurable> = false];
  %ArrayGlobalFuncObj["notinspec" = %freeze]; // Not in spec! Will ses delete this?
  %defineOwnProperty(%ArrayProto,
      "constructor",
      {[] "value" : {#value %ArrayGlobalFuncObj, #writable true},
          "configurable" : {#value true, #writable true},
          "enumerable" : {#value false, #writable true}}) }

let [%getCurrentUTC] = func() { prim("current-utc-millis", "ignored") }

let [%parse] = func(v) { 0 } // TODO: implement

let [%CheckObjectCoercible] = func(o) {
  if (o === undefined || o === null) {
    %TypeError("Not object coercible")
  } else { undefined }
}

let [%charatlambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (position = %ToInteger(args["0"]))
  let (size = prim("strlen", S))
  if (prim("<", position, 0) || prim(">=", position, size)) {
    ""
  } else { 
    prim("char-at", S, position)
  }
}

let [%charat] = {[#code : %charatlambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%charat,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%StringProto,
  "charAt",
  {[] "value" : {#value %charat, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%charcodeatlambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (position = %ToInteger(args["0"]))
  let (size = prim("strlen", S))
  if (prim("<", position, 0) || prim(">=", position, size)) {
    NaN
  } else { 
    prim("ascii_cton", prim("char-at", S, position))
  }
}

let [%charcodeat] = {[#code : %charcodeatlambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%charcodeat,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%StringProto,
  "charCodeAt",
  {[] "value" : {#value %charcodeat, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%strconcatlambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (end = args["length"])
  rec (loop = func(i, soFar) {
    if (prim("<", i, end)) {
      let (next = %ToString(args[prim("prim->str", i)]))
      loop(prim("+", i, 1), prim("string+", soFar, next))
    } else { soFar }
  })
  loop(0, S)
}

let [%strconcat] = {[#code : %strconcatlambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%strconcat,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%StringProto,
  "concat",
  {[] "value" : {#value %strconcat, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%min] = func(a, b) {
  if (prim("<=", a, b)) { a } else { b }
}
let [%max] = func(a, b) {
  if (prim("<=", a, b)) { b } else { a }
}

let [%substringlambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (len = prim("strlen", S))
  let (intStart = %ToInteger(args["0"]))
  let (intEnd =
    let (end = args["1"])
    if (end === undefined) { len } else { %ToInteger(end) })
  let (finalStart = %min(%max(intStart, 0), len))
  let (finalEnd = %min(%max(intEnd, 0), len))
  let (from = %min(finalStart, finalEnd))
  let (to = %max(finalStart, finalEnd))
  rec (loop = func(i, soFar) {
    if (prim("<", i, to)) {
      loop(prim("+", i, 1), prim("string+", soFar, prim("char-at", S, i)))
    } else { soFar }
  })
  loop(from, "")
}

let [%substring] = {[#code : %substringlambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%substring,
  "length",
  {[] "value" : {#value 2, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%StringProto,
  "substring",
  {[] "value" : {#value %substring, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%splicelambda] = func(this, args) {
  let (start = args["0"])
  let (deleteCount = args["1"])

  let (O = %ToObject(this))
  let (emptyobj = {[]})
  let (A = 
    {[#proto : %ArrayProto, #class : "Array",] 
        "length" : {#value 0, #writable true}})
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (relativeStart = %ToInteger(start))
  let (actualStart = 
    if (prim("<", relativeStart, 0)) {
      %max(prim("+", len, relativeStart), 0)
    } else {
      %min(relativeStart, len)
    })
  let (actualDeleteCount =
       %min(%max(%ToInteger(deleteCount), 0), prim("-", len, actualStart))) {

      rec (writeToALoop = func(k) {
	  if (prim("<", k, actualDeleteCount)) {
	      let (from = %ToString(prim("+", actualStart, k)))
	      if (prim("hasProperty", O, from)) {
		  let (fromValue = O[from])
		      %defineOwnProperty(A,
					 %ToString(k),
					 {[] "value" : {#value fromValue, #writable true},
					  "writable" : {#value true, #writable true},
					  "enumerable" : {#value true, #writable true},
					  "configurable" : {#value true, #writable true}});
		  A["length" = prim("+", A["length"], 1)];
		  writeToALoop(prim("+", k, 1))
	      } else {
		  writeToALoop(prim("+", k, 1))
	      }
	  } else { undefined }
      })
      writeToALoop(0);
      
      let (itemCount = prim("-", args["length"], 2)) {
	  let (step1 = func() {
	      if (prim("<", itemCount, actualDeleteCount)) {
		  let (end = prim("-", len, actualDeleteCount))
		  rec (writeToOLoop = func(k) {
		      if (prim("<", k, end)) {
			  let (from = %ToString(prim("+", k, actualDeleteCount)))
			  let (to = %ToString(prim("+", k, itemCount)))
			  if (prim("hasProperty", O, from)) {
			      O[to = O[from] ];
			      writeToOLoop(prim("+", k, 1))
			  } else { 
			      O[delete to];
			      writeToOLoop(prim("+", k, 1))
			  }
		      } else { undefined }
		  })
		  writeToOLoop(actualStart);
		  
		  let (delLimit = prim("+", prim("-", len, actualDeleteCount), itemCount))
		  rec (deleteloop = func(k) {
		      if (prim(">", k, delLimit)) {
			  let (next = prim("-", k, 1))
			  O[delete %ToString(next)];
			  deleteloop(next)
		      } else { undefined }
		  })
		  deleteloop(len)
	      } else { null }
	  })
	  step1();
	  
	  let (step2 = func() {
	      if (prim(">", itemCount, actualDeleteCount)) {
		  rec (writeToOLoop = func(k) {
		      if (prim(">", k, actualStart)) {
			  let (from = %ToString(prim("+", k, prim("-", actualDeleteCount, 1))))
			  let (to = %ToString(prim("+", k, prim("-", itemCount, 1))))
			  if (prim("hasProperty", O, from)) {
			      O[to = O[from] ];
			  writeToOLoop(prim("-", k, 1))
			  } else { 
			      O[delete to];
			      writeToOLoop(prim("-", k, 1))
			  }
		      } else { undefined }
		  })
		  
		  writeToOLoop(prim("-", len, actualDeleteCount))
	      } else {
		  undefined
	      }
	  })
	  step2();
	  
	  let (outerEnd = args["length"])
	  rec(outerloop = func(k, argsIndex) {
	      if (prim("<", argsIndex, outerEnd)) {
		  O[%ToString(k) = args[prim("prim->str", argsIndex)] ];
		  outerloop(prim("+", k, 1), prim("+", argsIndex, 1))
	      } else { undefined }
	  })
	  outerloop(actualStart, 2);
	  O["length" = prim("+", prim("-", len, actualDeleteCount), itemCount)];
	  A
      }
  }
}

let [%splice] = {[#code : %splicelambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%splice,
  "length",
  {[] "value" : {#value 2, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%ArrayProto,
  "splice",
  {[] "value" : {#value %splice, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%unshiftlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (argCount = args["length"]) {

      rec (Oloop = func(k) {
	  if (prim(">", k, 0)) {
	      let (from = %ToString(prim("-", k, 1)))
	      let (to = %ToString(prim("+", k, prim("-", argCount, 1))))
	      if (prim("hasProperty", O, from)) {
		  O[to = O[from] ];
		  Oloop(prim("-", k, 1))
	      } else { 
		  O[delete to];
		  Oloop(prim("-", k, 1))
	      }
	  } else { undefined }
      })
      Oloop(len);

      let (end = args["length"])
      rec (argsLoop = func(argsIndex, j) {
	  if (prim("<", argsIndex, end)) {
	      O[%ToString(j) = args[prim("prim->str", argsIndex)] ];
	      argsLoop(prim("+", argsIndex, 1), prim("+", j, 1))
	  } else { undefined }
      })
      argsLoop(0, 0);
      
      let (finalLen = prim("+", len, argCount)) {
	  O["length" = finalLen];
	  finalLen
      }
  }
}

let [%unshift] = {[#code : %unshiftlambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%unshift,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%ArrayProto,
  "unshift",
  {[] "value" : {#value %unshift, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%aiolambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (negOne = prim("-", 0, 1))

    label ret: {
	if (len === 0) {
	    break ret negOne
	} else { undefined };
	
	let (n = if (args["1"] === undefined) { 0 } else { %ToInteger(args["1"]) }) {
	    if (prim(">=", n, len)) {
		break ret negOne
	    } else { undefined };
	    
	    rec (loop = func(k) {
		if (prim("<", k, len)) {
		    let (kStr = %ToString(k))
		    if (prim("hasProperty", O, kStr)) {
			let (elementK = O[kStr])
			if (args["0"] === elementK) {
			    break ret k
			} else { undefined };
			loop(prim("+", k, 1))
		    } else { 
			loop(prim("+", k, 1))
		    }
	    } else { undefined }
	    })
	    let (start = if (prim(">=", n, 0)) { n } else {
		    %max(prim("-", len, prim("abs", n)), 0)
	    }) {
		loop(start);
		break ret negOne
	    }
	}
    }
}

let [%arrayIndexOf] = {[#code : %aiolambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%arrayIndexOf,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%ArrayProto,
  "indexOf",
  {[] "value" : {#value %arrayIndexOf, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%aliolambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (negOne = prim("-", 0, 1))

    label ret: {
	if (len === 0) {
	    break ret negOne
	} else { undefined };
	
	let (n = if (args["1"] === undefined) { prim("-", len, 1) } 
	     else { %ToInteger(args["1"]) })
	rec (loop = func(k) {
	    if (prim(">=", k, 0)) {
		let (kstr = %ToString(k))
		if (prim("hasProperty", O, kstr)) {
		    if (O[kstr] === args["0"]) {
			break ret k
		    } else { loop(prim("-", k, 1)) }
		} else { loop(prim("-", k, 1)) } 
	    } else { undefined }
	})
	
	let (start = if (prim(">=", n, 0)) { %min(n, prim("-", len, 1)) }
	     else { prim("-", len, prim("abs", n)) })
	loop(start);
	break ret negOne
    }
}

let [%arrayLastIndexOf] = {[#code : %aliolambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%arrayLastIndexOf,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%ArrayProto,
  "lastIndexOf",
  {[] "value" : {#value %arrayLastIndexOf, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%foreachlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (callbackfn = args["0"])
  
  label ret: {

      if (prim("typeof", callbackfn) !== "function") {
          %TypeError("Callback not a function in forEach")
      } else { undefined };
      
      let (T = args["1"])
      rec (loop = func(k) {
          if (prim("<", k, len)) {
              let (Pk = %ToString(k))
              if (prim("hasProperty", O, Pk)) {
                  let (kValue = O[Pk])
                  let (argslist = 
                       {[] "0" : {#value kValue, #writable true},
                        "1" : {#value k, #writable true},
                        "2" : {#value O, #writable true}})
                  callbackfn(T, argslist);
                  loop(prim("+", k, 1))
              } else {
                  loop(prim("+", k, 1))
              }
          } else { undefined }
      })
      loop(0);
      undefined
  }
}

let [%foreach] = {[#code : %foreachlambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%foreach,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%define15Property(%ArrayProto, "forEach", %foreach)}

let [%maplambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])
  
    label ret: {
	if (prim("typeof", callbackfn) !== "function") {
      %TypeError("Callback not a function in map")
	} else { null };
	
	let (T = args["1"])
	let (A = {[#proto : %ArrayProto, #class : "Array",]})
	
	rec (loop = func(k) {
	    if (prim("<", k, len)) {
		let (Pk = %ToString(k))
		if (prim("hasProperty", O, Pk)) {
		    let (kValue = O[Pk])
		    let (argsObj = {[]}) {
			argsObj["0" = kValue];
			argsObj["1" = k];
			argsObj["2" = O];
			argsObj["length" = 3];
			let (mappedValue = callbackfn(T, argsObj))
			    %defineOwnProperty(A,
					       Pk,
					       {[] "value" : {#value mappedValue, #writable true},
						"writable" : {#value true, #writable true},
						"enumerable" : {#value true, #writable true},
						"configurable" : {#value true, #writable true}});
			loop(prim("+", k, 1))
		    }
		} else {
		    loop(prim("+", k, 1))  
		}
	    } else { A["length" = k] }
	}) {
	
	    loop(0);
	    break ret A
	}
    }
}

let [%map] = {[#code : %maplambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%map,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%ArrayProto,
  "map",
  {[] "value" : {#value %map, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%filterlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])

    label ret: {
	if (prim("typeof", callbackfn) !== "function") {
      %TypeError("Callback not a function in filter")
	} else { null };
	
	let (T = args["1"])
  let (A = {[#proto : %ArrayProto, #class : "Array",]
            "length": {#value 0, #writable true}})
	
	rec (loop = func(k, to) {
	    if (prim("<", k, len)) {
		let (Pk = %ToString(k))
		if (prim("hasProperty", O, Pk)) {
		    let (kValue = O[Pk])
		    let (argsObj = {[]}) {
			argsObj["0" = kValue];
			argsObj["1" = k];
			argsObj["2" = O];
			argsObj["length" = 3];
			let (selected  = callbackfn(T, argsObj))
			if (%ToBoolean(selected)) {
				%defineOwnProperty(A, %ToString(to),
						   {[] "value" : {#value kValue, #writable true},
						    "writable" : {#value true, #writable true},
						    "enumerable" : {#value true, #writable true},
						    "configurable" : {#value true, #writable true}});
			    loop(prim("+", k, 1), prim("+", to, 1))
			} else {
			    loop(prim("+", k, 1), to)
			}
		    }
		} else {
		    loop(prim("+", k, 1), to)
		}
	    } else { 
		A["length" = to]
	    }
	}) {
	    loop(0, 0);
	    break ret A
	}
    }
}

let [%filter] = {[#code : %filterlambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%ArrayProto,
  "filter",
  {[] "value" : {#value %filter, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%reducelambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])

    label ret: {
	if (prim("typeof", callbackfn) !== "function") {
      %TypeError("Callback not a function in reduce")
	} else { null };

	if (len === 0 && prim("<", args["length"], 2)) {
      %TypeError("Reducing an empty list with not enough arguments.")
	} else { null };

	let (origK = 0)
	let (accumulator = if (prim(">=", args["length"], 2)) { args["1"] } else {
	    rec (accumLoop = func(k) {
		if (prim("<", k, len)) {
		    let (Pk = %ToString(k))
		    let (kPresent = prim("hasProperty", O, Pk))
		    if (kPresent) {
			origK := k;
			O[Pk]
		    } else {
			accumLoop(prim("+", k, 1))
		    }
		} else { %TypeError("In Array reduce") }
	    })
	    accumLoop(0)
	})
	
	rec (outerLoop = func(k, accumulator) {
	    if (prim("<", k, len)) {
		let (Pk = %ToString(k))
		let (kPresent = prim("hasProperty", O, Pk))
		if (kPresent) {
		    let (kValue = O[Pk])
		    let (argsObj = {[]}) {
			argsObj["0" = accumulator];
			argsObj["1" = kValue];
			argsObj["2" = k];
			argsObj["3" = O];
			argsObj["length" = 4];
			let (next = callbackfn(undefined, argsObj))
			outerLoop(prim("+", k, 1), next)
		    }
		} else {
		    outerLoop(prim("+", k, 1), accumulator)
		}
	    } else { accumulator }
	})

	break ret outerLoop(origK, accumulator)
    }
}

let [%reduce] = {[#code : %reducelambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%reduce,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }
  
{%defineOwnProperty(%ArrayProto,
  "reduce",
  {[] "value" : {#value %reduce, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%everylambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])

    label ret: {
	if (prim("typeof", callbackfn) !== "function") {
      %TypeError("Callback not function in every")
	} else { null };

	let (T = args["1"])
	rec (loop = func(k) {
	    if (prim("<", k, len)) {
		let (Pk = %ToString(k))
		let (kPresent = prim("hasProperty", O, Pk))
		if (kPresent) {
		    let (kValue = O[Pk])
		    let (argsObj = {[]}) {
			argsObj["0" = kValue];
			argsObj["1" = k];
			argsObj["2" = O];
			argsObj["length" = 3];
			let (testResult = callbackfn(T, argsObj))
			if (%ToBoolean(testResult) === false) {
			    false
			} else {
			    loop(prim("+", k, 1))
			}
		    }
		} else {
		    loop(prim("+", k, 1))
		}
	    } else { true }
	})

	break ret loop(0)
    }
}

let [%every] = {[#code : %everylambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%every,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }
  
{%defineOwnProperty(%ArrayProto,
  "every",
  {[] "value" : {#value %every, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%somelambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])

    label ret: {
	if (prim("typeof", callbackfn) !== "function") {
    %TypeError("Callback not function in some")
	} else { null };

	let (T = args["1"])
	rec (loop = func(k) {
	    if (prim("<", k, len)) {
		let (Pk = %ToString(k))
		let (kPresent = prim("hasProperty", O, Pk))
		if (kPresent) {
		    let (kValue = O[Pk])
		    let (argsObj = {[]}) {
			argsObj["0" = kValue];
			argsObj["1" = k];
			argsObj["2" = O];
			argsObj["length" = 3];
			let (testResult = callbackfn(T, argsObj))
			if (%ToBoolean(testResult) === true) {
			    true
			} else {
			    loop(prim("+", k, 1))
			}
		    }
		} else {
		    loop(prim("+", k, 1))
		}
	    } else { false }
	})

	break ret loop(0)
    }
}

let [%some] = {[#code : %somelambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%some,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }
  
{%defineOwnProperty(%ArrayProto,
  "some",
  {[] "value" : {#value %some, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%reduceRightLambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])

    label ret: {
	if (prim("typeof", callbackfn) !== "function") {
    %TypeError("Callback not function in reduceRight")
	} else { null };
	
	if (len === 0 && prim("<", args["length"], 2)) {
    %TypeError("Zero-length array in reduceRight")
	} else { null };
	
	let (origK = prim("-", len, 1))
	let (accumulator = if (prim(">=", args["length"], 2)) { args["1"] } else {
	    rec (accumLoop = func(k) {
		if (prim(">=", k, 0)) {
		    let (Pk = %ToString(k))
		    let (kPresent = prim("hasProperty", O, Pk))
		    if (kPresent) {
			origK := k;
			O[Pk]
		    } else {
			accumLoop(prim("-", k, 1))
		    }
		} else { %TypeError("reduceRight") }
	    })
	    accumLoop(origK)
	})
	
	rec (outerLoop = func(k, accumulator) {
	    if (prim(">=", k, 0)) {
		let (Pk = %ToString(k))
		let (kPresent = prim("hasProperty", O, Pk))
		if (kPresent) {
		    let (kValue = O[Pk])
		    let (argsObj = {[]}) {
			argsObj["0" = accumulator];
			argsObj["1" = kValue];
			argsObj["2" = k];
			argsObj["3" = O];
			argsObj["length" = 4];
			let (next = callbackfn(undefined, argsObj))
			outerLoop(prim("-", k, 1), next)
		    }
		} else {
		    outerLoop(prim("-", k, 1), accumulator)
		}
	    } else { accumulator }
	})
	
	break ret outerLoop(origK, accumulator)
    }
}

let [%reduceRight] = {[#code : %reduceRightLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%reduceRight,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }
  
{%defineOwnProperty(%ArrayProto,
  "reduceRight",
  {[] "value" : {#value %reduceRight, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%slicelambda] = func(this, args) {
  let (O = %ToObject(this))
  let (A = {[#proto : %ArrayProto, #class : "Array",]
            "length": {#value 0, #writable true}})
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (relativeStart = %ToInteger(args["0"]))

  let (initk = if (prim("<", relativeStart, 0)) {
    let (added = prim("+", len, relativeStart))
    if (prim(">", added, 0)) { added } else { 0 }
    } else {
      if (prim("<", relativeStart, len)) { relativeStart } else { len }
    })

  let (relativeEnd = if (args["1"] === undefined) { len } 
    else { %ToInteger(args["1"]) })

  let (final = if (prim("<", relativeEnd, 0)) {
    let (added = prim("+", len, relativeEnd))
    if (prim(">", added, 0)) { added } else { 0 }
  } else {
    if (prim("<", relativeEnd, len)) { relativeEnd } else { len }
  })

    rec (loop = func(n, k, finalLen) {
	label ret: {
	    if (prim(">=", k, final)) {
		break ret finalLen
	    } else { null };

	    let (Pk = %ToString(k))
	    let (kPresent = prim("hasProperty", O, Pk))
	    if (kPresent) {
		let (kValue = O[Pk])
		    %defineOwnProperty(A,
				       %ToString(n),
				       {[] "value" : {#value kValue, #writable true},
					"writable" : {#value true, #writable true},
					"configurable" : {#value true, #writable true},
					"enumerable" : {#value true, #writable true}});
		break ret loop(prim("+", n, 1), prim("+", k, 1), prim("+", finalLen, 1))
	    } else {
		break ret loop(prim("+", n, 1), prim("+", k, 1), prim("+", finalLen, 1))
	    }
	}}) {

	A["length" = loop(0, initk, 0)];
	A
    }
}

let [%slice] = {[#code : %slicelambda, #proto : %FunctionProto,]}

{ %defineOwnProperty(%slice,
    "length",
    {[] "value" : {#value 2, #writable true},
        "configurable" : {#value false, #writable true}}) }

{ %defineOwnProperty(%ArrayProto,
    "slice",
    {[] "value" : {#value %slice, #writable true},
        "configurable" : {#value true, #writable true}}) }

let [%bindLambda] = func(this, args) {
  label ret: {
    if (prim("typeof", this) !== "function") {
      %TypeError("this not function in bind")
    } else { null };

    let (thisArg = args["0"])
    let (A = %slicelambda(args, %oneArgObj(1)))
    let (mkNewObj = func(proto) {
      let (proto = if(%IsObject(proto)) { proto } else { %ObjectProto })
      {[#proto: proto, #class: "Object", #extensible: true,]}
    })
    let (Flambda = func(this_inner, args_inner) {
      let (thisArg = if (args_inner["%new"]) {
        mkNewObj(this["prototype"])
      } else {
        thisArg
      })
      let (concatted = %concatLambda(A, args_inner))
      this(thisArg, concatted)
    })
    let (F = {[#code : Flambda, #proto : %FunctionProto, #class : "Function",]})
    let (addthrower = func(name) {
      %defineOwnProperty(F,
             name,
             {[] "get" : {#value %ThrowTypeError, #writable true},
          "set" : {#value %ThrowTypeError, #writable true},
          "enumerable" : {#value false, #writable true},
          "configurable" : {#value false, #writable true}})
    })
    let (FLength = if (this[<#class>] === "Function") {
      let (L = prim("-", this["length"], A["length"])) %max(0, L)}
      else { 0 }) {
        %defineOwnProperty(F,
               "length",
               {[] "value" : {#value FLength, #writable true},
            "writable" : {#value false, #writable true},
            "enumerable" : {#value false, #writable true},
            "configurable" : {#value false, #writable true}});
  
        addthrower("caller");
        addthrower("arguments");
        break ret F
    }
  }
}

let [%bind] = {[#code : %bindLambda, #proto : %FunctionProto,]}

{ %defineOwnProperty(%bind,
    "length",
    {[] "value" : {#value 1, #writable true},
        "configurable" : {#value false, #writable true}}) }

{ %define15Property(%FunctionProto, "bind", %bind) }

let [%numToStringAbstract] = func(n, r) {
    rec (nts = func(n, r) {
	label ret: {
	    if (n !== n) {
		break ret "NaN"
	    } else { null };

	    if (n === 0) {
		break ret "0"
	    } else { null };

	    if (prim("<", n, 0)) {
		let (negOne = prim("-", 0, 1))
		let (newN = prim("*", n, negOne))
		break ret prim("string+", "-", nts(newN, r))
	    } else { null };

	    if (n === +inf) {
		break ret "Infinity"
	    } else { null };

	    if (r === 10) {
		break ret prim("prim->str", n)
	    } else { null };
	    break ret prim("base", n, r)
	}})
  nts(n, r)
}

let [%numberToStringlambda] = func(this, args) {
  let (notNumProto = this !== %NumberProto)
  if (notNumProto && this[<#proto>] !== %NumberProto) {
    throw {[#proto : %TypeErrorProto,]}
  } else { 
    let (rint = if (args["0"] === undefined) { 10 } else { %ToInteger(args["0"]) })
    if (rint === 10) {
      %numToStringAbstract(this[<#primval>], 10)
    } else {
      if (prim("!", prim("typeof", rint) === "number")) {
        throw "RangeError"
      } else {
        if (prim("<", rint, 2) || prim(">", rint, 36)) {
          throw "RangeError"
        } else {
          %numToStringAbstract(this[<#primval>], rint)
        }
      }
    }
  }
}

let [%numberToString] = 
  { [#code : %numberToStringlambda, #proto: %FunctionProto, #class: "Function",] }

{%define15Property(%numberToString, "length", 1)}

{%define15Property(%NumberProto, "toString", %numberToString)}

let [%StringIndexOflambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (searchStr = %ToString(args["0"]))
  let (pos = %ToInteger(args["1"]))
  let (len = prim("strlen", S))
  let (start = %min(%max(pos, 0), len))
  let (searchLen = prim("strlen", searchStr))

  let (check_k = func(k) {
    rec (check_j = func(j) {
      if (j === searchLen) { true } else {
        if (prim("char-at", S, prim("+", k, j)) !== prim("char-at", searchStr, j)) {
          false
        } else { check_j(prim("+", j, 1)) }
      }
    })
    if (prim("!", prim("<=", prim("+", k, searchLen), len))) { false } else {
      if (prim("!", check_j(0))) { false } else { true }
    }
  })
  rec (find_k = func(curr) {
    if (prim(">", prim("+", curr, searchLen), len)) { prim("-", 0, 1) } else {
      if (check_k(curr)) { curr } else {
        find_k(prim("+", curr, 1))
      }
    }
  })

  find_k(start)
}

let [%StringIndexOf] = { [#code : %StringIndexOflambda, #proto : %FunctionProto,]}

{ %StringIndexOf["length" = 1];
  %StringIndexOf["length"<#enumerable> = false];
  %StringIndexOf["length"<#configurable> = false];
  %StringIndexOf["length"<#writable> = false];
  %StringProto["indexOf" = %StringIndexOf]}

let [%replacelambda] = func(this, args) {
  let (S = %ToString(this))
  let (search = %ToString(args["0"]))
  let (replace = args["1"])
  if(typeof replace !== "function") { throw "String.replace() only supports functions" }
  else {
    rec (loop = func(str) {
      let (start = %StringIndexOflambda(str, %oneArgObj(search))) {
        if (start === prim("-", 0, 1)) { str }
        else {
          let (replaced = %ToString(replace(undefined, %oneArgObj(replace))))
          let (before = %substringlambda(str, %twoArgObj(0, start)))
          let (afterix = prim("+", start, prim("strlen", search)))
          let (after = %substringlambda(str, %oneArgObj(afterix))) {
            prim("string+", before,
              prim("string+", replaced,
              loop(after)))
          }
        }
      }
    }) {
      loop(S)
    }
  }
}

let [%replace] = { [#code : %replacelambda, #proto : %FunctionProto,] }

{ %StringProto["replace" = %replace] }

let [%sliolambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (searchStr = %ToString(args["0"]))
  let (numPos = %ToNumber(args["1"]))
  let (pos = 
    if (numPos !== numPos) { 
      +inf
    } else { %ToInteger(numPos) })
  let (len = prim("strlen", S))
  let (start = %min(%max(pos, 0), len))
  let (searchLen = prim("strlen", searchStr))

  let (check_k = func(k) {
    rec (check_j = func(j) {
      if (j === searchLen) { true } else {
        if (prim("char-at", S, prim("+", k, j)) !== prim("char-at", searchStr, j)) {
          false
        } else { check_j(prim("+", j, 1)) }
      }
    })
    if (prim("!", prim("<=", prim("+", k, searchLen), len))) { false } else {
      if (prim("!", check_j(0))) { false } else { true }
    }
  })
  rec (find_k = func(curr) {
    if (prim("<", curr, 0)) { prim("-", 0, 1) } else {
      if (check_k(curr)) { curr } else {
        find_k(prim("-", curr, 1))
      }
    }
  })

  find_k(start)
}

let [%StringLastIndexOf] = {[#code : %sliolambda, #proto : %FunctionProto,]}

{ %StringLastIndexOf["length" = 1];
  %StringLastIndexOf["length"<#enumerable> = false];
  %StringLastIndexOf["length"<#configurable> = false];
  %StringLastIndexOf["length"<#writable> = false];
  %StringProto["lastIndexOf" = %StringLastIndexOf]}

let [%localeCompareLambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (That = %ToString(args["0"]))
  prim("locale-compare", S, That)
}

let [%localeCompare] = {[#code : %localeCompareLambda, #proto : %FunctionProto,]}

{ %localeCompare["length" = 1];
  %localeCompare["length"<#enumerable> = false];
  %localeCompare["length"<#configurable> = false];
  %localeCompare["length"<#writable> = false];
  %StringProto["localeCompare" = %localeCompare]}

let [%stringSliceLambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (len = prim("strlen", S))
  let (intStart = %ToInteger(args["0"]))
  let (end = args["1"])
  let (intEnd = if (end === undefined) { len } else { %ToInteger(end) })
  let (from = if (prim("<", intStart, 0)) { 
    %max(prim("+", len, intStart), 0) } else { %min(intStart, len) })
  let (to = if (prim("<", intEnd, 0)) { 
    %max(prim("+", len, intEnd), 0) } else { %min(intEnd, len) })
  let (span = %max(prim("-", to, from), 0))
  rec (build = func(i, result) {
    if (prim("<", i, span)) {
      let (next = prim("string+", result, prim("char-at", S, prim("+", from, i))))
      build(prim("+", i, 1), next)
    } else { result }
  })
  build(0, "")
}

let [%stringSlice] = {[#code : %stringSliceLambda, #proto : %FunctionProto,]}

{ %stringSlice["length" = 2];
  %stringSlice["length"<#enumerable> = false];
  %stringSlice["length"<#configurable> = false];
  %stringSlice["length"<#writable> = false];
  %StringProto["slice" = %stringSlice]}

let [%tlclambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  prim("to-lower", S)
}

let [%toLowerCase] = {[#code : %tlclambda, #proto : %FunctionProto,]}

{%StringProto["toLowerCase" = %toLowerCase]}

let [%tuclambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  prim("to-upper", S)
}

let [%toUpperCase] = {[#code : %tuclambda, #proto : %FunctionProto,]}

{%StringProto["toUpperCase" = %toUpperCase]}

// Turkish language support NYI
{%StringProto["toLocaleLowerCase" = %toLowerCase];
 %StringProto["toLocaleUpperCase" = %toUpperCase]}

let [%splitLambda] = func(this, args) {
  "String.prototype.split NYI"
}

let [%split] = {[#code : %splitLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%StringProto,
  "split",
  {[] "value" : {#value %split, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%IsFinite] = func(n) {
  prim("!", (n !== n || n === +inf || n === -inf))
}

// http://es5.github.com/#x15.9.1.2
let [%msPerDay] = 86400000
let [%msPerHour] = 3600000
let [%msPerMin] = 60000
let [%msPerSecond] = 1000
let [%Day] = func(t) { prim("floor", prim("/", t, %msPerDay)) }
let [%TimeWithinDay] = func(t) { prim("%", t, %msPerDay) }

// http://es5.github.com/#x15.9.1.3
let [%DaysInYear] = func(y) {
  if (prim("%", y, 4) !== 0) {
    365
  }
  else {
    if (prim("%", y, 400) === 0 || prim("%", y, 100) !== 0) {
      366
    }
    else {
      365
    }
  }
}

// http://es5.github.com/#DayFromYear
let [%DayFromYear] = func(y) {
  let (fragment = func(offset, coefficient) {
    prim("floor", prim("/", prim("-", y, offset), coefficient))
  })
  let (base = prim("*", 365, prim("-", y, 1970)))
  let (part1 = fragment(1969, 4))
  let (part2 = fragment(1901, 100))
  let (part3 = fragment(1601, 400))
  prim("+", prim("-", prim("+", base, part1), part2), part3)
}

// http://es5.github.com/#TimeFromYear 
let [%TimeFromYear] = func(y) {
  prim("*", %msPerDay, %DayFromYear(y))
}

// http://es5.github.com/#YearFromTime
let [%YearFromTime] = func(t) {
  let (sign = if (prim(">", t, 0)) {1} else { prim("-", 0, 1) })
  let (start = if (sign === 1) {1969} else {1970})
  rec (loop = func(y) {
    if (prim("<=", %TimeFromYear(y), t)
        && prim(">", %TimeFromYear(prim("+", 1, y)), t)) {
      y
    }
    else {
      loop(prim("+", y, sign))
    }
  })
  loop(start)
}

// http://es5.github.com/#x15.9.1.4
let [%DayWithinYear] = func(t) {
  prim("-", %Day(t), %DayFromYear(%YearFromTime(t)))
}

// http://es5.github.com/#InLeapYear
let [%InLeapYear] = func(t) {
  if(%DaysInYear(%YearFromTime(t)) === 365) {
    0
  } else {
    1
  }
}

let [%DaysInMonth] = func(m, leap) {
  let (m = prim("%", m, 12))
  if (m === 3 || m === 5 || m === 8 || m === 10) {
    30
  } else if (m === 1) {
    prim("+", 28, leap)
  } else {
    31
  }
}

// NOTE(joe): It might be obvious to others, but it wasn't to me.  Since
// January is month #0 and February is month #1, and they happen before
// the leap day, they are being treated specially by the algorithms
// below.  For March and beyond, we can generalize the behavior into
// helpers, but the first two cases both require special handling.

// http://es5.github.com/#x15.9.1.4
let [%MonthFromTime] = func(t) {
  let (DayWithinYear = func(t) {
    prim("-", %Day(t), %DayFromYear(%YearFromTime(t)))
  })
  let (CheckLeapRange = func(start, end) {
    prim("<=", prim("+", start, %InLeapYear(t)), DayWithinYear(t)) &&
    prim("<", DayWithinYear(t), prim("+", end, %InLeapYear(t)))
  })
  if (prim("<=", 0, %DayWithinYear(t)) &&
      prim("<", %DayWithinYear(t), 31)) {
    0
  } else if(prim("<=", 31, %DayWithinYear(t)) &&
            prim("<", %DayWithinYear(t), prim("+", 59, %InLeapYear(t)))) {
    1
  }
  else if(CheckLeapRange(59, 90)) { 2 }
  else if(CheckLeapRange(90, 120)) { 3 }
  else if(CheckLeapRange(120, 151)) { 4 }
  else if(CheckLeapRange(151, 181)) { 5 }
  else if(CheckLeapRange(181, 212)) { 6 }
  else if(CheckLeapRange(212, 243)) { 7 }
  else if(CheckLeapRange(243, 273)) { 8 }
  else if(CheckLeapRange(273, 304)) { 9 }
  else if(CheckLeapRange(304, 334)) { 10 }
  else if(CheckLeapRange(334, 365)) { 11 }
  else { %TypeError("Something terrible in date %MonthFromTime")}
}

// http://es5.github.com/#x15.9.1.5
let [%DateFromTime] = func(t) {
  let (mft = %MonthFromTime(t))
  let (CalcDay = func(offset) {
    prim("-", prim("-", %DayWithinYear(t), offset), %InLeapYear(t))
  })
  if (mft === 0) { prim("+", %DayWithinYear(t), 1) }
  else if (mft === 1) { prim("-", %DayWithinYear(t), 30) }
  else if (mft === 2) { CalcDay(58) }
  else if (mft === 3) { CalcDay(89) }
  else if (mft === 4) { CalcDay(119) }
  else if (mft === 5) { CalcDay(150) }
  else if (mft === 6) { CalcDay(180) }
  else if (mft === 7) { CalcDay(211) }
  else if (mft === 8) { CalcDay(242) }
  else if (mft === 9) { CalcDay(272) }
  else if (mft === 10) { CalcDay(303) }
  else if (mft === 11) { CalcDay(333) }
  else { %TypeError("Something terrible happened in %DateFromTime")}
}

let [%LocalTime] = func(t) { t }

let [%MakeDate] = func(day, time) { prim("+", prim("*", day, %msPerDay), time) }

// http://es5.github.com/#x15.9.1.12
// Implementation draws heavily from the date test harness
let [%MakeDay] = func(yr, mt, date) {
  if (prim("!", (%IsFinite(yr) && %IsFinite(mt) && %IsFinite(date)))) {
    NaN
  }
  else {
    let (y = %ToInteger(yr))
    let (m = %ToInteger(mt))
    let (dt = %ToInteger(date))
    let (ym = prim("+", y, prim("floor", prim("/", m, 12))))
    let (mn = prim("%", m, 12))
    let (yt = %TimeFromYear(y))
    rec (loop = func(t, mo, leap) {
      if(prim("<", mo, m)) {
        let (leap = %InLeapYear(t))
        let (t = prim("+", t, prim("*", %DaysInMonth(mo, leap), %msPerDay)))
        loop(t, prim("+", mo, 1), leap)
      } else {
        t
      }
    }) {
    let (t = loop(yt, 0, %InLeapYear(yt)))
    if (%YearFromTime(t) !== ym ||
        %MonthFromTime(t) !== mn ||
        %DateFromTime(t) !== 1) {
      NaN
    } else {
      prim("-", prim("+", %Day(t), dt), 1)
    }
  }
  }
}

let [%MakeTime] = func(h, m, s, ms) {
  if (prim("!", (%IsFinite(h) && %IsFinite(m) && %IsFinite(s) && %IsFinite(ms)))) {
    NaN
  }
  else {
    let (hour = %ToInteger(h))
    let (min = %ToInteger(m))
    let (sec = %ToInteger(s))
    let (millis = %ToInteger(ms))
    let (t = prim("+",
      prim("+",
        prim("+",
          prim("*", hour, %msPerHour),
          prim("*", min, %msPerMin)),
        prim("*", sec, %msPerSecond)),
      millis)) {
      t
    }
  }

}

// http://es5.github.com/#x15.9.1.9
// S5 has no time zone adjustments or daylight savings time.
// It is, for the time being, indifferent to your i18n and l10n concerns.
let [%UTC] = func(t) { t }

let [%getYearlambda] = func(this, args) { 78 } // TODO: implement

let [%getYear] = { [#code : %getYearlambda,] }

let [%getMonthlambda] = func(this, args) { 3 } // TODO: implement

let [%getMonth] = { [#code: %getMonthlambda,] }

{(/*:START SYM EVAL*/0)}

let [%DateProto] = { 
  [#proto : %ObjectProto, #class: "Date",]
  "getYear" : {#value %getYear, #writable false},
  "getMonth": {#value %getMonth, #writable false},
}

{(/*:STOP SYM EVAL*/0)}



let [%dateToStringLambda] = func(this, args) {
  "Date toString NYI"
}

let [%dateToString] = {[#code : %dateToStringLambda, #proto : %FunctionProto,]}

{%define15Property(%DateProto, "toString", %dateToString)}

let [%dateValueOfLambda] = func(this, args) {
  this[<#primval>]
}

let [%dateValueOf] = {[#code : %dateValueOfLambda, #proto : %FunctionProto,]}

{%DateProto["valueOf" = %dateValueOf] }


// http://es5.github.com/#x15.9.1.14
let [%TimeClip] = func(t) {
  if (prim("!", %IsFinite(t) &&
      prim("<=", prim("abs", t), 8.64e15))) {
    NaN
  } else {
    %ToInteger(t)
  }
}

let [%DateConstructor] = func(this, args) {
  let (calledAsFunction = this === undefined)
  let (nargs = args["length"])
  if (calledAsFunction) {
    let (v = %getCurrentUTC())
    let (o = 
    { [#proto : %DateProto, #class : "Date", #extensible : true, #primval : v,] })
    %dateToStringLambda(o, {[]})
  } else {
    if (nargs === 0) {
      let (v = %getCurrentUTC())
      { [#proto : %DateProto, #class : "Date", #extensible : true, #primval : v,] }
    }
    else if (nargs === 1) {
      let (v = %ToPrimitive(args["0"]))
      let (V =
        if (prim("typeof", v) === "string") { %parse(v) } else { %ToNumber(v) })
      let (clipped = %TimeClip(V))
      { [#proto : %DateProto, #class : "Date", #extensible : true, #primval : clipped,] }
    } else {
      let (y = %ToNumber(args["0"]))
      let (m = %ToNumber(args["1"]))
      let (dt = if (args["2"] === undefined) { 1 } else { %ToNumber(args["2"]) })
      let (h = if (args["3"] === undefined) { 0 } else { %ToNumber(args["3"]) })
      let (min = if (args["4"] === undefined) { 0 } else { %ToNumber(args["4"]) })
      let (s = if (args["5"] === undefined) { 0 } else { %ToNumber(args["5"]) })
      let (milli = if (args["6"] === undefined) { 0 } else { %ToNumber(args["6"]) })
      let (yr = 
        let (tiy = %ToInteger(y))
        let (rangecond1 = prim("<", 0, tiy) || 0 === tiy)
        let (rangecond2 = prim("<", tiy, 99) || tiy === 99)
        if (y !== y && rangecond1 && rangecond2) {
          prim("+", 1900, tiy) } else { y })
      let (finalDate = %MakeDate(%MakeDay(yr, m, dt), %MakeTime(h, min, s, milli)))
      let (primval = %TimeClip(%UTC(finalDate))) {
        { [#proto : %DateProto, #class : "Date", #extensible : true, #primval : primval,] }
      }
    }
  }
}

let [%DateGlobalFuncObj] = { [#code : %DateConstructor, #proto : %FunctionProto,]
                             "prototype" : {#value %DateProto, #writable true} }

// http://es5.github.com/#x15.9.5.26
let [%dateGetTimezoneOffsetLambda] = func(this, args) {
  let (t = this[<#primval>])
  if (t === NaN) { NaN }
  else {
    0
  }
}

let [%dateGetTimezoneOffset] = {[
    #code : %dateGetTimezoneOffsetLambda,
    #proto : %FunctionProto,
  ]}

{%define15Property(%DateProto, "getTimezoneOffset", %dateGetTimezoneOffset)}

let [%dategetDayLambda] = func(this, args) {
  let (day = prim("floor", prim("/", this[<#primval>], %msPerDay)))
  let (weekday = prim("%", prim("+", day, 4), 7)) {
    weekday
  }
}

let [%dategetDay] = {[#code : %dategetDayLambda, #proto : %FunctionProto,]}

{%define15Property(%DateProto, "getDay", %dategetDay)}

let [%dategetDateLambda] = func(this, args) {
  let (t = this[<#primval>])
  if (t === NaN) { t } else { %DateFromTime(%LocalTime(t)) }
}

let [%dategetDate] = {[#code: %dategetDateLambda, #proto : %FunctionProto,]}

{%define15Property(%DateProto, "getDate", %dategetDate)}

let [%defineNYIProperty] = func(base, name) {
  let (unimplFunc = func(this, args) {
    %TypeError(prim("string+", name, " NYI"))
  })
  let (unimplObj = {[#code: unimplFunc, #proto: %FunctionProto,]})
  %define15Property(base, name, unimplObj)
}

{
  %defineNYIProperty(%DateGlobalFuncObj, "parse");
  %defineNYIProperty(%DateGlobalFuncObj, "UTC");
  %defineNYIProperty(%DateProto, "getTime");
  %defineNYIProperty(%DateProto, "getFullYear");
  %defineNYIProperty(%DateProto, "getUTCFullYear");
  %defineNYIProperty(%DateProto, "getUTCMonth");
//  %defineNYIProperty(%DateProto, "getDate");
  %defineNYIProperty(%DateProto, "getUTCDate");
  %defineNYIProperty(%DateProto, "getUTCDay");
  %defineNYIProperty(%DateProto, "getHours");
  %defineNYIProperty(%DateProto, "getUTCHours");
  %defineNYIProperty(%DateProto, "getMinutes");
  %defineNYIProperty(%DateProto, "getUTCMinutes");
  %defineNYIProperty(%DateProto, "getSeconds");
  %defineNYIProperty(%DateProto, "getUTCSeconds");
  %defineNYIProperty(%DateProto, "getMilliseconds");
  %defineNYIProperty(%DateProto, "getUTCMilliseconds");
  %defineNYIProperty(%DateProto, "setTime");
  %defineNYIProperty(%DateProto, "setMilliseconds");
  %defineNYIProperty(%DateProto, "setUTCMilliseconds");
  %defineNYIProperty(%DateProto, "setSeconds");
  %defineNYIProperty(%DateProto, "setUTCSeconds");
  %defineNYIProperty(%DateProto, "setMinutes");
  %defineNYIProperty(%DateProto, "setUTCMinutes");
  %defineNYIProperty(%DateProto, "setHours");
  %defineNYIProperty(%DateProto, "setUTCHours");
  %defineNYIProperty(%DateProto, "setDate");
  %defineNYIProperty(%DateProto, "setUTCDate");
  %defineNYIProperty(%DateProto, "setMonth");
  %defineNYIProperty(%DateProto, "setUTCMonth");
  %defineNYIProperty(%DateProto, "setFullYear");
  %defineNYIProperty(%DateProto, "setUTCFullYear");
  %defineNYIProperty(%DateProto, "toUTCString");
  %defineNYIProperty(%DateProto, "toGMTString");
  %defineNYIProperty(%DateProto, "setYear")
}

let [%testlambda] = func(this, args) {
  prim("print", "You used the es5.env testlambda.  Are you sure you didn't forget to include the regexp.js library, or regexp.env?")
}

let [%test] = { [#code : %testlambda,] }

{(/*:START SYM EVAL*/0)}

let [%RegExpProto] = { [#proto : %ObjectProto,]
  "test" : {#value %test, #writable false} }

{(/*:STOP SYM EVAL*/0)}

let [%RegExpConstructor] = func(this, args) {
  {[#proto : %RegExpProto,]}
}

let [%RegExpGlobalFuncObj] = {[#code : %RegExpConstructor, #proto : %FunctionProto,]
  "prototype" : {#value %RegExpProto, #writable false},
  "length" : {#value 2,
              #writable false,
              #configurable false,
              #enumerable false}}

{%RegExpProto["constructor" = %RegExpGlobalFuncObj]}

/* NOTE(Justin) Does not match spec (http://es5.github.com/#x15.1.2.2).
   We are ignoring any radix argument and using OCaml's float_of_string func. */
let [%parseIntlambda] = func(this, args) {
  let (numstr = %ToString(args["0"]))
  prim("numstr->num", numstr)
}

let [%parseInt] = { [#code : %parseIntlambda, #proto : %FunctionProto,] }

let [%decodeURILambda] = func(this, args) {
  "decodeURI NYI"
}

let [%decodeURI] = {[#code : %decodeURILambda, #proto: %FunctionProto,]}

let [%decodeURIComponentLambda] = func(this, args) {
  "decodeURIComponent NYI"
}

let [%decodeURIComponent] = {[#code : %decodeURIComponentLambda, #proto: %FunctionProto,]}

let [%encodeURILambda] = func(this, args) {
  "encodeURI NYI"
}

let [%encodeURI] = {[#code : %encodeURILambda, #proto: %FunctionProto,]}

let [%encodeURIComponentLambda] = func(this, args) {
  "encodeURIComponent NYI"
}

let [%encodeURIComponent] = {[#code : %encodeURIComponentLambda, #proto: %FunctionProto,]}

let [%explambda] = func() {
  undefined
}

let [%exp] = { [#code : %explambda,] }

let [%Math] = { []
  "E" : {#value 2.7182818284590452354, #writable false},
  "LN10": {#value 2.302585092994046, #writable false},
  "LN2" : {#value 0.6931471805599453, #writable false},
  "LOG2E" : {#value 1.4426950408889634, #writable false},
  "LOG10E" : {#value 0.4342944819032518, #writable false},
  "PI" : {#value 3.141592653589793, #writable false},
  "SQRT1_2" : {#value 0.7071067811865476, #writable false},
  "SQRT2" : {#value 1.4142135623730951, #writable false},
  "exp" : {#value %exp, #writable false} }

let [%minMaxLambda] = func(this, args, op, init) {
  let (end = args["length"])

    label ret: {
	if (end === 0) {
	    break ret init
	} else { null };

	rec (loop = func(best, i) {
	    if (prim("<", i, end)) {
		let (curr = %ToNumber(args[prim("prim->str", i)]))
		if (curr !== curr) {
		    break ret NaN
		} else { null };

		loop(op(best, curr), prim("+", i, 1))
	    } else { best }
	})
	break ret loop(init, 0)
    }
}

let [%mathMinLambda] = func(this, args) {
  %minMaxLambda(this, args, %min, +inf)
}

let [%mathMin] = {[#code : %mathMinLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%mathMin,
  "length",
  {[] "value" : {#value 2, #writable true},
      "configurable" : {#value false, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%Math,
  "min",
  {[] "value" : {#value %mathMin, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%mathMaxLambda] = func(this, args) {
  %minMaxLambda(this, args, %max, -inf)  
}

let [%mathMax] = {[#code : %mathMaxLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%mathMax,
  "length",
  {[] "value" : {#value 2, #writable true},
      "configurable" : {#value false, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%Math,
  "max",
  {[] "value" : {#value %mathMax, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%mathAbsLambda] = func(this, args) {
  let (n = %ToNumber(args["0"]))
    label ret: {
	if (n !== n) { break ret n } else { null };
	if (n === -inf) { break ret +inf} else { null };
	break ret prim("abs", n)
    }
}

let [%mathAbs] = {[#code : %mathAbsLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "abs",
  {[] "value" : {#value %mathAbs, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%acosLambda] = func(this, args) {
  "acos NYI"
}

let [%acos] = {[#code : %acosLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "acos",
  {[] "value" : {#value %acos, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%asinLambda] = func(this, args) {
  "asin NYI"
}

let [%asin] = {[#code : %asinLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "asin",
  {[] "value" : {#value %asin, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%atanLambda] = func(this, args) {
  "atan NYI"
}

let [%atan] = {[#code : %atanLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "atan",
  {[] "value" : {#value %atan, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%atan2Lambda] = func(this, args) {
  "atan2 NYI"
}

let [%atan2] = {[#code : %atan2Lambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "atan2",
  {[] "value" : {#value %atan2, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%cosLambda] = func(this, args) {
  "cos NYI"
}

let [%cos] = {[#code : %cosLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "cos",
  {[] "value" : {#value %cos, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%randomLambda] = func(this, args) {
  4 // IEEE-Vetted random number
}

let [%random] = {[#code : %randomLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "random",
  {[] "value" : {#value %random, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%roundLambda] = func(this, args) {
  "round NYI"
}

let [%round] = {[#code : %roundLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "round",
  {[] "value" : {#value %round, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%sinLambda] = func(this, args) {
  let (n = %ToNumber(args["0"])) {
    label ret: {
      if (n !== n) {
        break ret n
      } else { null };

      if (n === 0) {
        break ret n
      } else { null };

      if (n === +inf) {
        break ret nan
      } else { null };

      if (n === -inf) {
        break ret nan
      } else { null };

      break ret prim("sin", n)
    }
  }
}

let [%sin] = {[#code : %sinLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "sin",
  {[] "value" : {#value %sin, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%sqrtLambda] = func(this, args) {
  "sqrt NYI"
}

let [%sqrt] = {[#code : %sqrtLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "sqrt",
  {[] "value" : {#value %sqrt, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%tanLambda] = func(this, args) {
  "tan NYI"
}

let [%tan] = {[#code : %tanLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "tan",
  {[] "value" : {#value %tan, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%mathLogLambda] = func(this, args) {
  let (n = %ToNumber(args["0"]))
    label ret: {
	if (n !== n) { break ret n } else { null };
	if (prim("<", n, 0)) { break ret NaN } else { null };
	if (n === 0) { break ret -inf } else { null };
	if (n === 1) { break ret 0 } else { null };
	if (n === +inf) { break ret n } else { null };
	break ret prim("log", n)
    }
}

let [%mathLog] = {[#code : %mathLogLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "log",
  {[] "value" : {#value %mathLog, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%mathCeilLambda] = func(this, args) {
  let (x = %ToNumber(args["0"]))
    label ret: {
	if (x !== x || x === 0 || x === -inf || x === +inf) {
	    break ret x
	} else { null };
	break ret prim("ceil", x)
    }
}

let [%mathCeil] = {[#code : %mathCeilLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "ceil",
  {[] "value" : {#value %mathCeil, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%mathFloorLambda] = func(this, args) {
  let (x = %ToNumber(args["0"]))
    label ret: {
	if (x !== x || x === 0 || x === -inf || x === +inf) {
	    break ret x
	} else { null };
	break ret prim("floor", x)
    }
}
  
let [%mathFloor] = {[#code : %mathFloorLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "floor",
  {[] "value" : {#value %mathFloor, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%PrimAdd] = func(l, r) {
    if (prim("typeof", l) === "string" &&
        prim("typeof", r) === "string") {
        prim("string+", l, r)
    } else {
        prim("+", %AssertNumber(l), %AssertNumber(r))
    }
}

let [%PrefixOp] = func(obj, fld, op) {
  let (oldValue = obj[fld])
    let (newValue = op(oldValue, 1)) {
	obj[fld = newValue];
	newValue
    }
}

let [%PrefixIncrement] = func(obj, fld) {
  %PrefixOp(obj, fld, %PrimAdd)
}

let [%mathPowLambda] = func(this, args) {
    let (x = %ToNumber(args["0"]))
    let (y = %ToNumber(args["1"]))

    label ret: {
	if (y !== y) {
            break ret NaN
	} else { null };

	if (y === 0) {
            break ret 1
	} else { null };

	if (x !== x && y !== 0) {
            break ret NaN
	} else { null };

	let (absX = prim("abs", x)) {
	if (prim(">", absX, 1) && y === +inf) {
            break ret +inf
	} else { null };

	if (prim(">", absX, 1) && y === -inf) {
            break ret 0
	} else { null };

	if (absX === 1 && ((y === +inf) || (y === -inf))) {
            break ret NaN
	} else { null };

	if (prim("<", absX, 1) && y === +inf) {
            break ret 0
	} else { null };

	if (prim("<", absX, 1) && y === -inf) {
            break ret +inf
	} else { null };

	if (x === +inf && prim(">", y, 0)) {
            break ret +inf
	} else { null };

	if (x === +inf && prim("<", y, 0)) {
            break ret 0
	} else { null };

	let (isOdd = func(n) {
            let (divided = prim("/", n, 2))
            (prim("floor", n) === n) && (prim("floor", divided) !== divided)
	}) {
	if (x === -inf && prim(">", y, 0)) {
            break ret if (isOdd(y)) { -inf } else { +inf }
	} else { null };

	if (x === -inf && prim("<", y, 0)) {
            break ret 0
	} else { null };

	if (x === 0 && prim(">", y, 0)) {
            break ret 0
	} else { null };

	if (x === 0 && prim("<", y, 0)) {
            break ret +inf
	} else { null };

	// If x is -0 and y<0 and y is an odd integer, the result is -inf
	// If x is -0 and y<0 and y is not an odd integer, the result +inf
	let (oddY = isOdd(y))
	if (x === 0 && prim("<", y, 0) && oddY) {
            break ret -inf
	} else { null };
	if (x === 0 && prim("<", y, 0)) {
            break ret +inf
	} else { null };

	let (isFinite = func(n) {
            n !== +inf && n !== -inf
	})
	let (finiteX = isFinite(x))
	let (finiteY = isFinite(y))
	if (prim("<", x, 0) && finiteX && finiteY && prim("floor", y) !== y) {
            break ret NaN
	} else { null };

	break ret prim("pow", x, y)
    }}}
}

let [%mathPow] = {[#code : %mathPowLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
    "pow",
    {[] "value" : {#value %mathPow, #writable true},
        "configurable" : {#value true, #writable true}}) }

let [%valueOfLambda] = func(this, args, proto, typestr) {
  let (hasWrongProto = this[<#proto>] !== proto)
  let (hasWrongTypeof = typeof(this) !== typestr)
  let (isntProto = this !== proto)
  if (hasWrongProto && hasWrongTypeof && isntProto) {
    %TypeError("valueOf")
  } else {
    if (hasWrongTypeof) { this[<#primval>] } else { this }
  }
}

let [%stringValueOf] = 
  {[#code : func(this, args) { 
      %valueOfLambda(this, args, %StringProto, "string") 
    },
    #proto : %FunctionProto,]}

{%defineOwnProperty(%StringProto,
  "valueOf",
  {[] "value" : {#value %stringValueOf, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%numValueOf] = 
  {[#code : func(this, args) { 
      %valueOfLambda(this, args, %NumberProto, "number") 
    },
    #proto : %FunctionProto,]}

{%defineOwnProperty(%NumberProto,
  "valueOf",
  {[] "value" : {#value %numValueOf, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%booleanValueOf] = 
 {[#code : func(this, args) { 
    %valueOfLambda(this, args, %BooleanProto, "boolean")
  },
  #proto : %FunctionProto,]}

{%defineOwnProperty(%BooleanProto,
  "valueOf",
  {[] "value" : {#value %booleanValueOf, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%toFixedLambda] = func(this, args) {
  let (f = %ToInteger(args["0"]))
    label ret: {
	if (prim("<", f, 0) || prim(">", f, 20)) {
	    throw %JSError({[#proto : %RangeErrorProto,]})
	} else { null };

	let (x = if (prim("typeof", this) === "number") { this } 
	     else { this[<#primval>] })
	if (x !== x) {
	    break ret "NaN"
	} else { null };

	if (prim(">=", x, 1e21)) {
	    break ret %ToString(x)
	} else { null };

	break ret prim("to-fixed", x, f)
    }
}

let [%toFixed] = {[#code : %toFixedLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%toFixed,
  "length",
  {[] "value" : {#value 1, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

{%defineOwnProperty(%NumberProto,
  "toFixed",
  {[] "value" : {#value %toFixed, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%numTLSLambda] = func(this, args) {
  let (x = if (prim("typeof", this) === "number") { this } 
    else { this[<#primval>] })
  let (obj = {[#proto : %StringProto, #primval : prim("prim->str", x),]})
  %toLocaleStringLambda(obj, {[]})
}

let [%numTLS] = {[#code : %numTLSLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%NumberProto,
  "toLocaleString",
  {[] "value" : {#value %numTLS, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%toExponentialLambda] = func(this, args) {
  // TODO: implement
  "toExponential NYI"
}

let [%toExponential] = {[#code : %toExponentialLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%NumberProto,
  "toExponential",
  {[] "value" : {#value %toExponential, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%toPrecisionLambda] = func(this, args) {
  // TODO: implement
  "toPrecision NYI"
}

let [%toPrecision] = {[#code : %toPrecisionLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%NumberProto,
  "toPrecision",
  {[] "value" : {#value %toPrecision, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%PrimSub] = func(l, r) {
    prim("-", %AssertNumber(l), %AssertNumber(r))
}

let [%BitwiseAnd] = func(l, r) {
  prim("&", %ToInt32(l), %ToInt32(r))
}

let [%SignedRightShift] = func(l, r) {
  prim(">>", %ToInt32(l), %ToUint32(r))
}

let [%LeftShift] = func(l, r) {
  prim("<<", %ToInt32(l), %ToUint32(r))
}

let [%UnsignedRightShift] = func(l, r) {
  prim(">>>", %ToUint32(l), %ToUint32(r))
}

let [%PrefixDecrement] = func(obj, fld) {
  %PrefixOp(obj, fld, %PrimSub)
}

let [%PostfixOp] = func(obj, fld, op) {
  let (oldValue = obj[fld])
    let (newValue = op(oldValue, 1)) {
	obj[fld = newValue];
	oldValue
    }
}

let [%PostDecrement] = func(obj, fld) {
  %PostfixOp(obj, fld, %PrimSub)
}

let [%PostIncrement] = func(obj, fld) {
  %PostfixOp(obj, fld, %PrimAdd)
}

let [%PrimMultOp] = func(l, r, op) {
  op(%AssertNumber(l), %AssertNumber(r))
}

let [%CompareOp] = func(l, r, LeftFirst) {
  let (rest = func(px, py) {
    let (pxtype = prim("typeof", px))
    let (pytype = prim("typeof", py))

    label ret: {
      if (pxtype !== "string" && pytype !== "string") {
          let (px = %AssertNumber(px))
          let (py = %AssertNumber(py)) {
              if (px !== px || py !== py) {
                break ret undefined
              } else { null };

              if (px === py) {
                break ret false
              } else { null };

              // TODO(matt): not sure how to compare -0 vs. 0

              if (px === +inf) {
                break ret false
              } else { null };

              if (py === +inf) {
                break ret true
              } else { null };

              if (py === -inf) {
                break ret false
              } else { null };

              if (px === -inf) {
                break ret true
              } else { null };

              break ret prim("<", px, py)
        }
      } else {
        break ret prim("string<", %AssertString(px), %AssertString(py))
      }
    }
  })

  rest(l, r)
}

let [%LessThan] = func(l, r) {
  let (result = %CompareOp(l, r, true))
  if (result === undefined) { false } else { result }
}

let [%GreaterThan] = func(l, r) {
  let (result = %CompareOp(r, l, false))
  if (result === undefined) { false } else { result }
}

let [%LessEqual] = func(l, r) {
  let (result = %CompareOp(r, l, false))
  (result !== undefined) && prim("!", result)
}

let [%GreaterEqual] = func(l, r) {
  let (result = %CompareOp(l, r, true))
  (result !== undefined) && prim("!", result)
}

let [%BitwiseInfix] = func(l, r, op) {
  let (lnum = %ToInt32(l))
  let (rnum = %ToInt32(r))
  op(lnum, rnum)
}


let [%EnvCheckAssign] = func(context, id, val, strict) {
  if (%isUnbound(context, id) && strict) {
    throw %JSError(
      {[#proto : %ReferenceErrorProto,] message: {#value id, #writable true}}
    )
  } else {
    try {
      %set-property(context, id, val)
    } catch {
      %UnwritableDispatch(id)
    }
  }
}

// 11.4.6
let [%UnaryPlus] = func(expr) {
    %AssertNumber(expr)
}

// 11.4.7
let [%UnaryNeg] = func(expr) {
  let (oldValue = %AssertNumber(expr))
  let (negOne = prim("-", 0, 1))
  prim("*", oldValue, negOne)
}


let [%BitwiseNot] = func(expr) {
  let (oldValue = %ToInt32(expr))
  prim("~", oldValue)
}

let [%logLambda] = func(o, s) {
  rec (loop = func(i) {
    if (prim("hasProperty", s, prim("prim->str", i))) {
      prim("pretty", s[prim("prim->str", i)]);
      loop(prim("+", i, 1))
    } else {
      undefined
    }
  })  
  loop(0)
}

let [%log] = { [#code : %logLambda, #proto: %FunctionProto,] }

let [%console] = {
  [#proto: null,]
  "log": {#value %log, #writable false},
  "info": {#value %log, #writable false},
  "warn": {#value %log, #writable false},
  "error": {#value %log, #writable false}
}

let [%makeContextVarDefiner] = func() {
  let (envstore = {[#extensible: true,]})
  func(context, id) {
    // If we are using the real, honest-to-goodness global context,
    // then we should be adding bindings to global.  This will only happen
    // if the passed context is %nonstrictContext from an indirect eval
    let (envstore = if (context === %globalContext) { %global } else { envstore})
    if (prim("hasOwnProperty", context, id)) {
      if (prim("!", prim("hasProperty", envstore, id))) {
        envstore[id = undefined]
      };
      undefined /* do nothing, var exists */
    } else {
      
      // This line is necessary for global vars to appear with just a var
      // statement and no assignment
      envstore[id = undefined];
      let (%setter = {[#code: func(this, args) {
        if (prim("hasProperty", envstore, id)) {
          envstore[id = args["0"]]
        }
        else {
          %UnboundId(id)
        }
      },]})
      let (%getter = {[#code: func(this, args) {
        if (prim("hasProperty", envstore, id)) {
          envstore[id]
        }
        else {
          %UnboundId(id)
        }
      },]})
      %defineOwnProperty(context, id, {[]
        "get": {#value %getter, #writable true},
        "set": {#value %setter, #writable true}
      })
    }
  }
}

{
  %global["window" = %global];
  %global["print" = %print];
  %global["console" = %console];
  %global["Array" = %ArrayGlobalFuncObj];
  %global["Array"<#enumerable> = false];
  %global["String" = %StringGlobalFuncObj];
  %global["String"<#enumerable> = false];
  %global["Object" = %ObjectGlobalFuncObj];
  %global["Object"<#enumerable> = false];
  %global["Number" = %NumberGlobalFuncObj];
  %global["Number"<#enumerable> = false];
  %global["Boolean" = %BooleanGlobalFuncObj];
  %global["Boolean"<#enumerable> = false];
  %global["Date" = %DateGlobalFuncObj];
  %global["Date"<#enumerable> = false];
  %global["isNaN" = %isNaN];
  %global["isNaN"<#enumerable> = false];
  %global["Math" = %Math];
  %global["Math"<#enumerable> = false];
  %global["parseInt" = %parseInt];
  %global["parseInt"<#enumerable> = false];
  %global["decodeURI" = %decodeURI];
  %global["decodeURI"<#enumerable> = false];
  %global["decodeURIComponent" = %decodeURIComponent];
  %global["decodeURIComponent"<#enumerable> = false];
  %global["encodeURI" = %encodeURI];
  %global["encodeURI"<#enumerable> = false];
  %global["encodeURIComponent" = %encodeURIComponent];
  %global["encodeURIComponent"<#enumerable> = false];
  %global["TypeError" = %TypeErrorGlobalFuncObj];
  %global["TypeError"<#enumerable> = false];
  %global["ReferenceError" = %ReferenceErrorGlobalFuncObj];
  %global["ReferenceError"<#enumerable> = false];
  %global["SyntaxError" = %SyntaxErrorGlobalFuncObj];
  %global["SyntaxError"<#enumerable> = false];
  %global["RangeError" = %RangeErrorGlobalFuncObj];
  %global["RangeError"<#enumerable> = false];
  %global["URIError" = %URIErrorGlobalFuncObj];
  %global["URIError"<#enumerable> = false];
  %global["Error" = %ErrorGlobalFuncObj];
  %global["Error"<#enumerable> = false];
  %global["RegExp" = %RegExpGlobalFuncObj];
  %global["RegExp"<#enumerable> = false];

  %ObjectProto["propertyIsEnumerable" = %propertyIsEnumerable];
  %ObjectProto["propertyIsEnumerable"<#enumerable> = false]
}

{%global["NaN" = NaN];
 %global["NaN"<#enumerable> = false];
 %global["NaN"<#configurable> = false];
 %global["NaN"<#writable> = false]}

{%global["Infinity" = +inf];
 %global["Infinity"<#enumerable> = false];
 %global["Infinity"<#configurable> = false];
 %global["Infinity"<#writable> = false]}

{%global["undefined" = undefined];
 %global["undefined"<#enumerable> = false];
 %global["undefined"<#configurable> = false];
 %global["undefined"<#writable> = false]}

let [%isFiniteLambda] = func(this, args) {
  let (n = %ToNumber(args["0"]))
  %IsFinite(n)
}

let [%isFinite] = {[#code : %isFiniteLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%global,
  "isFinite",
  {[] "value" : {#value %isFinite, #writable true},
      "enumerable" : {#value false, #writable true},
      "configurable" : {#value true, #writable true},
      "writable" : {#value true, #writable true}}) }

let [%parseFloatLambda] = func(this, args) {
  "parseFloat NYI"
}

let [%parseFloat] = {[#code : %parseFloatLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%global,
  "parseFloat",
  {[] "value" : {#value %parseFloat, #writable true},
      "enumerable" : {#value false, #writable true},
      "configurable" : {#value true, #writable true},
      "writable" : {#value true, #writable true}}) }

let [%escapeLambda] = func(this, args) {
  "escape NYI"
}

let [%escape] = {[#code : %escapeLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%global,
  "escape",
  {[] "value" : {#value %escape, #writable true},
      "enumerable" : {#value false, #writable true},
      "configurable" : {#value true, #writable true},
      "writable" : {#value true, #writable true}}) }

let [%unescapeLambda] = func(this, args) {
  "unescape NYI"
}

let [%unescape] = {[#code : %unescapeLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%global,
  "unescape",
  {[] "value" : {#value %unescape, #writable true},
      "enumerable" : {#value false, #writable true},
      "configurable" : {#value true, #writable true},
      "writable" : {#value true, #writable true}}) }

{(/*:START SYM EVAL*/0)}

let [%makeWithContext] = func(context, object) {
  let (names = %propertyNames(object, true))
  let (mksetter = func(id) {
   {[#code: func(this, args) {
     if(prim("hasProperty", object, id)) {
       object[id = args["0"]]
     } else {
       context[id = args["0"]]
     }
    },]}
  })
  let (mkgetter = func(id) {
   {[#code: func(this, args) {
     if(prim("hasProperty", object, id)) {
       object[id]
     } else {
       context[id]
     }
    },]}
  })
  let (newcontext = {[#extensible: true, #proto: context,]})
  let (addBinding = func(id) {
    %defineOwnProperty(newcontext, id, {[]
      "set": {#value mksetter(id), #writable true},
      "get": {#value mkgetter(id), #writable true},
      "configurable": {#value true, #writable true},
      "enumerable": {#value true, #writable true}
    })
  }) {
    %primEach(names, addBinding);
    newcontext
  }
}

// Set up global environment
let [%this] = %global
let [%strictContext] = %globalContext
let [%nonstrictContext] = %globalContext

{(/*:USER CODE BELOW*/0)}
